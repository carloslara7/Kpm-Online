package com.kpm.reporter.excel{	import com.kpm.kpm.*;		/**		 *Constructor de la clase.		 *Representa un hash de Burbujas a Categoria		 */				public class HashGameCategory		{			private var hash:Object;			private var categories:Array;				//Constructor de la clase			public function HashGameCategory()			{				hash = new Object();				loadCategories();				createHash();			}						//Carga en un arreglo de la clase todas las categorias de los bubbles (juegos).			//La información se toma del archivo EBStd.			private function loadCategories():void			{				var arr:Array = EBStd.Consts;								categories = new Array();								for (var i:int = 0; i < arr.length; i++)				{					switch ((arr[i] as EBStd).Text){						case "Numbers_Count"	: 	categories.push("Count Finger&5Frame3-to-20");											  		categories.push("Count DiceDots&Numeral-3-to-20");											  		break;						case "Numbers_Identify" :   categories.push("IdentifyNumber");													break;						case "Numbers_Subset"	:	categories.push("Subset Finger&5Frame3-to-20");													categories.push("Subset DiceDots&Numeral3-to-20");													break;						case "Geometry"			:	categories.push("Shape");													break;						case "SpatialSense"		:	categories.push("Spatial");													break;						case "DataMeasurements"	:	categories.push("Data");													break;						case "Addition"			:	categories.push("Addition");													break;													case "Comparison"		:	categories.push("Comparison");														break;												}				}			}						//Crea el Hash en donde la clave es la burbuja (juego) y el valor es la categoria del mismo.			private function createHash():void			{				var bubbleNames:Array = new Array();				var bubbleName:String;				var bubbleCategory:String;				var min,max:int;								hash = new Object();				bubbleNames = com.kpm.kpm.EBName.Consts; //Arreglo de burbujas (juegos) sin los niveles.								for (var i:int = 0; i < bubbleNames.length;i++)				{					bubbleName = (bubbleNames[i] as EBName).Text; //Nombre de cabecera del juego, por ejemplo:																  //SubsetDiceDots_7					bubbleCategory = getTabName((bubbleNames[i] as EBName));										if (bubbleCategory != "")					{						min = (bubbleNames[i] as EBName).MinLevel;						max = (bubbleNames[i] as EBName).MaxLevel;												for (min; min <= max; min++)						{													hash[bubbleName+"_"+min] = bubbleCategory;						}					}				}			}						private function getTabName(bubble:EBName):String			{				switch (bubble.Standard.Text){										case "Numbers_Count"	: 													switch (bubble.Text){													case "CountFinger_3":													case "CountFinger_5":													case "CountFinger_7":													case "CountFinger_10":													case "Count5Frame_3":													case "Count5Frame_5":													case "Count5Frame_7":													case "Count5Frame_10":													case "Count5Frame_15":													case "Count5Frame_20": return "Count Finger&5Frame3-to-20"; break;																										case "CountDiceDots_3":													case "CountDiceDots_5":													case "CountDiceDots_7":													case "CountDiceDots_10":													case "CountNumeral_3":													case "CountNumeral_5":													case "CountNumeral_7":													case "CountNumeral_10":													case "CountNumeral_15":													case "CountNumeral_20": return "Count DiceDots&Numeral-3-to-20"; break;													default : return ""; //El caso de CountMixed												}																							  												  						case "Numbers_Identify" :   if (bubble.Text != "IdentifyMixed")													return "IdentifyNumber";												else													return "";												break;										case "Numbers_Subset"	:													switch (bubble.Text){													case "SubsetFinger_3":													case "SubsetFinger_5":													case "SubsetFinger_7":													case "SubsetFinger_10":																										case "Subset5Frame_3":													case "Subset5Frame_5":													case "Subset5Frame_7":													case "Subset5Frame_10":													case "Subset5Frame_15":													case "Subset5Frame_20": return "Subset Finger&5Frame3-to-20"; break;																										case "SubsetDiceDots_3":													case "SubsetDiceDots_5":													case "SubsetDiceDots_7":													case "SubsetDiceDots_10":													case "SubsetNumeral_3":													case "SubsetNumeral_5":													case "SubsetNumeral_7":													case "SubsetNumeral_10": 													case "SubsetNumeral_15":													case "SubsetNumeral_20": return "Subset DiceDots&Numeral3-to-20"; break;													default: return ""; //El caso de SubsetMixed																										}																	case "Addition"		:			return "Addition";					case "Comparison"	:			switch (bubble.Text){													case "CompareEstimate_3":													case "CompareEstimate_5":													case "CompareEstimate_10":													case "CompareCorrespond_5":																										case "CompareCorrespond_10":													case "CompareCount_5":													case "CompareCount_10":													case "CompareDisorganized_5":													case "CompareDisorganized_10":													case "CompareDisorganized_15":													case "CompareMixed_5":													case "CompareMixed_10":	return "Comparison";													default: return ""; //El caso de SubsetMixed														break;													}																																			case "Geometry"			:	return "Shape";		break;																case "SpatialSense"		:	return "Spatial";	break;																case "DataMeasurements"	:	return "Data";		break;					default					:   return ""; 			break;				}			}						/**			 * Método que dado un nombre de una burbuja retorna la categoria de la misma.			 * @param key Es el nombre de la burbuja de la cual se desea averiguar la categoria.			 * 			 **/			public function getCategory(key:String):String			{				if (hash[key] == null)				{					return "";				}				else				{					return hash[key];				}			}						//Retorna un arreglo que contiene todas las categorias de las bubbles (juegos)			/**			 * Retorna un arreglo con todos los nombres de las categorias.			 * 			 **/			public function getCategories():Array			{				return categories.sort();			}						/**			 * Método que dado un nombre de una categoria retorna un arreglo con los nombres de todas las			 * burbujas pertenecientes a dicha categoria.			 * @param key Nombre de la categoria de la que se quiere obtener las burbujas.			 * 			 **/			public function getBubbles(key:String):Array			{				var arr: Array = new Array();								for (var b:String in hash)				{					if (hash[b] == key) 					{						arr.push(b);					}				}				return arr.sort(compare);			}						/**			Metodo que ordena las bubble a ser mostradas en el reporte.			**/			function compare(a:String, b:String):int {							var aParts:Array = a.split("_");				var bParts:Array = b.split("_");							if (String(aParts[0]) < String(bParts[0]))					return -1;				if (String(aParts[0]) > String(bParts[0]))					return 1;				if (Number(aParts[1]) < Number(bParts[1]))					return -1;				if (Number(aParts[1]) > Number(bParts[1]))					return 1;				if (Number(aParts[2]) < Number(bParts[2]))					return -1;				if (Number(aParts[2]) > Number(bParts[2]))					return 1;															return 0;			}					}}