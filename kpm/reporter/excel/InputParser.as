package com.kpm.reporter.excel{		import flash.events.*;	import flash.filesystem.File;	import flash.filesystem.FileMode;	import flash.filesystem.FileStream;	import flash.net.FileReference;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.utils.ByteArray;	import flash.xml.XMLDocument;	import com.kpm.common.Util;	import com.kpm.ui.UIGod;	import com.kpm.kpm.DriverData;		//import org.osmf.utils.URL;		/**	 * 	 * @author Manera, Torres, Vainstein	 * Clase InputParser	 */		public class InputParser extends EventDispatcher{				private var kid:Kid;		private var loader:URLLoader;		private var request:URLRequest;		private static const teacherProfile:String="111111111";				//Directorio de trabajo en donde estan los directorios de cada profile de los niños.		private var workspace:String;				//Arreglo en donde se guardan los directorios de cada niño.		private var kidsDir:Array;				private var patternDir:RegExp = /\d{9}/;		private var patternFile:RegExp = /\d{9}_profile.xml/;				/**		 *Constructor de la clase. 		 * 		 */				public function InputParser(workspace:String){            Util.debug("InputParser() " + workspace);			request = new URLRequest();			loader = new URLLoader();			this.workspace = workspace;			loader.addEventListener(Event.COMPLETE, createKid);			loader.addEventListener(IOErrorEvent.IO_ERROR, handleError);				}					/**		**/		public function getLongestIdLength():int{						if(kidsDir[0])			{				var pathArray:Array = kidsDir[0].toString().split("/");				var id:int =  int(pathArray[pathArray.length - 1]);				return id.toString().length;			}			else				return 2;		}				/**		 *Método para cargar los directorios de cada niño 		 * 		 */				public function loadDir(kidsID:Array):void{			Util.debug("InputParser.loadDir");			//Se crea el arreglo donde se guardan los directorios por cada niño			kidsDir = new Array();						//ID de un kid			var kidProfile:String;			//this.workspace = File.applicationDirectory.nativePath + "//" + this.workspace;			var directory:File = new File(workspace);						if(directory.exists==false) 			{				UIGod.feedback("No players! Login as teacher to create players (Directory)");				this.dispatchEvent(new Event("noKids"));				return; 			}				//throw new Error("Directorio "+ workspace+" de profiles inexistente.");						Util.debug("kids to be loaded");			Util.printArray(kidsID);						var list:Array = directory.getDirectoryListing();			Util.debug("Cargando directorio de profiles:", this);						var currDir:Array;            var dirLength : int;			for (var i:uint = 0; i < list.length; i++) {				if(list[i].nativePath.toString().match(patternDir) != undefined){					currDir = list[i].nativePath.toString().split(File.separator);                    dirLength = currDir[currDir.length-1].toString().length;					if(dirLength == 10){						kidProfile = currDir[currDir.length-1].toString(); 						//Se verifica si el niño debe ser incluído o no en el reporte.												if(kidsID)							Util.debug("finding kidprofile " +  kidsID.indexOf(kidProfile));												//se verifica si el nino esta en la clase adecuada						if(DriverData.configXML.classes.@currentId == kidProfile.charAt(0))						if((kidProfile !=teacherProfile) && ((kidsID == null) || (kidsID != null && kidsID.indexOf(kidProfile)!=-1)))						{							Util.debug("pushing " + list[i].nativePath.toString());							kidsDir.push(list[i].nativePath.toString());						}																	}				}						}				if(kidsDir.length==0) 			{				UIGod.feedback("No Data for players. Login as teacher to create players");				this.dispatchEvent(new Event("noKids"));				return;			}			//throw new Error("No existen profiles en el directorio: "+workspace)						Util.debug("Cargados " + kidsDir.length + " profiles", this);			Util.printArray(kidsDir);									//La lista se ordena de mayor a menor para poder hacer pop en el orden correcto			kidsDir.sort(Array.DESCENDING);					}				/**		 * Carga el xml del siguiente niño.		 * @return Retorna false si no quedan archivos.		 * 		 */				 		public function loadNextKid():void{					Util.debug("InputParser.loadNextKid");							var nextKidDirPath:String;			var nextKidDir:File;			var list:Array;			var nextKidFilePath:String;						nextKidDirPath = kidsDir.pop();									if (nextKidDirPath==undefined){				dispatchEvent(new Event("endOfParsing"));				return;			}						Util.debug("Cargando profile " + nextKidDirPath.substr(nextKidDirPath.length-9), this);						nextKidDir= new File(nextKidDirPath);			list = nextKidDir.getDirectoryListing();						for (var i:uint = 0; i < list.length; i++) {				if(list[i].nativePath.toString().match(patternFile)!=undefined){					nextKidFilePath=list[i].nativePath.toString();                    trace("nextKidFilePath " + nextKidFilePath);				}						}							var replacePattern:RegExp = /\//g;						nextKidFilePath=nextKidFilePath.replace(replacePattern,"//");						request.url=nextKidFilePath;						loader.load(request);										}				/**		 *Metodo para crear un niño utilizando la clase kid. 		 * @param e		 * 		 */				private function createKid(e:Event):void{						var xml:XML = new XML(e.target.data);			if(Profile.getType(xml) == "KID"){				kid = new Kid(xml);				dispatchEvent(new Event("kidLoaded"));						Util.debug("InputParser.createKid" + xml.UID);				//Util.debug(xml.toXMLString());							}			else{				this.loadNextKid()			}		}					private function handleError(event:IOErrorEvent):void{			trace("Error al cargar los datos.");		}				/**		 * Método para retornar el niño actual. 		 * @return Retorna el niño actual.		 * 		 */				public function getKid():Kid{			return kid;		}			}}