package com.kpm.reporter.pdf.standard{	import com.kpm.reporter.pdf.*;		import flash.display.Loader;	import flash.display.Sprite;	import flash.events.Event;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.utils.Dictionary;	import flash.xml.XMLDocument;	import flash.xml.XMLNode;	/**	Clase para generar reportes pdf "estandar" a partir de un xml de entrada.	**/	public class StandardPdfReport extends Sprite{				protected var xml:XML;		protected var error:Boolean;		protected var currentChild;		protected var tagGenerator:XmlTagGenerator;		protected var imgData:ImgData;		protected var dynamicParser:StandardDynamicParser;		protected var pageLeftMargin:int;		protected var pageRightMargin:int;		protected var pageWidth:int;			protected var atoms:AtomsList;				protected var orgCodes:XML;		protected var reportData:XML;		protected var orgCodesLoader:URLLoader;		protected var orgCodesRequest:URLRequest;		protected var reportDataLoader:URLLoader;		protected var reportDataRequest:URLRequest;				/**		Constructor. Recibe un archivo XML y un objeto atoms en donde se encuentran almacenados datos útiles para la		generación del reporte, en particular el path de las imágenes.		**/		public function StandardPdfReport(xml:XML,atoms:AtomsList){						this.atoms = atoms;			this.imgData = new ImgData(this.atoms.getObject("imagePath") as String);			this.tagGenerator = new XmlTagGenerator();			this.orgCodesLoader = new URLLoader();			this.orgCodesRequest = new URLRequest();			this.reportDataLoader = new URLLoader();			this.reportDataRequest = new URLRequest();			this.xml = this.xmlToLowerCase(xml);			this.setPageSize();			this.addOrgCodesFormats();			this.error = false;						this.imgData.addEventListener("imgsLoaded", this.loadOrgCodes);					this.reportDataLoader.addEventListener(Event.COMPLETE, this.parse);						this.orgCodesLoader.addEventListener(Event.COMPLETE, this.loadReportData);					}				/**		Método protegido que inicia la carga del archivo XML que contiene los KPM OrgCodes según el path indicado en atoms.		**/		protected function loadOrgCodes(e:Event):void{									this.orgCodesRequest.url = this.atoms.getObject("orgCodesPath") as String;			this.orgCodesLoader.load(orgCodesRequest);		}						/**		Método protegido que crea el objeto XML de OrgCodes a partir del archivo cargado e inicia la carga del archivo		ubicado en el path 'reportData', el cual contiene datos importantes (ejemplo: teacherName).		**/		protected function loadReportData(e:Event):void{			this.orgCodes = new XML(e.target.data);			this.reportDataRequest.url = this.atoms.getObject("reportData") as String;			this.reportDataLoader.load(reportDataRequest);		}						/**		Método protegido que agrega a la estructura atoms el teacherName obtenido del XML 'reportData'.		**/		protected function loadData():void{			//this.atoms.addAtom("teacherName", this.reportData.teacherName.toString());		}								/**		Metodo protegido que establece el ancho y los márgenes del documento si el xml tiene un formato válido.		**/		protected function setPageSize():void{			try{				var env:Environment = new Environment();				this.pageWidth = env.getPageSize("a4").width;						this.pageLeftMargin = 36;				this.pageRightMargin = 36;								if(this.xml.hasOwnProperty("@page-size")) this.pageWidth = env.getPageSize(String(env.validate("page-size", this.xml.attribute("page-size").toString().toLowerCase()))).width;				if(this.xml.hasOwnProperty("@margin-left")) this.pageLeftMargin = int(env.validate("number", this.xml.attribute("margin-left")));				if(this.xml.hasOwnProperty("@margin-right")) this.pageRightMargin = int(env.validate("number", this.xml.attribute("margin-right")));							}						catch(e:Error){} //Atrapa errores de Environment para poder continuar la ejecución.		}				/**		Metodo protegido que setea los formatos utilizados para presentar los OrgCodes en documento PDF.		**/		protected function addOrgCodesFormats(){			this.xml.prependChild(this.tagGenerator.format("orgCodes", 40));			this.xml.prependChild(this.tagGenerator.format("org", NaN, 11, "Calibri", "bold"));			this.xml.prependChild(this.tagGenerator.format("code", NaN, 11, "Calibri"));		}																/**		Metodo público que retorna el objeto XML generado.		**/		public function getOutput():XML{			return this.xml;		}				/**		Metodo público que genera el objeto XML que es entrada de la clase Parser.		Reemplaza información dinámica por información estática.		**/		public function generate():void{			imgData.loadImages();		}				/**		Método protegido para convertir a lowerCase todos los tags del objeto XML.		**/		protected function xmlToLowerCase(xml:XML):XML{			for each(var node:XML in xml.descendants()){				//trace(node.toXMLString());				node.setName(node.name().toString().toLowerCase());			}			return xml;		}				/**		Metodo protegido que intercambia el nodo Loop por una lista de nodos.		**/		protected function swapChilds(parentNode:XML,node:XML,currentChild:int):void{				var last:XMLList = parentNode.child(currentChild);			var index = currentChild+1;			for each(var child:XML in node.children()){								this.xml.insertChildAfter(last,child);				last = this.xml.child(index);				index++;			}			//Se elimina el nodo Loop original			delete xml.loop[0];					}														/**		Metodo protegido que se ejecuta (mediante un evento) luego de la carga datos necesarios como la información		de las imágenes utilizadas en la creación de qualifierLines y los archivos XML adicionales.		**/		protected function parse(e:Event):void{						this.reportData = new XML(e.target.data);			this.loadData();			var loopTag:XML = this.xml.loop[0];						var loopIndex:int = loopTag.childIndex();							var xmlList:XML = parseDynamicSection(loopTag);			this.swapChilds(this.xml, xmlList, loopIndex);											replaceDynamicData();			addOrgsLegend();			dispatchEvent (new Event("endStandard"));		}				/**		Método protegido que inserta al final del documento la referencia con el nombre correspondiente a cada 		organización seleccionada.		**/		protected function addOrgsLegend(){			var orgs:Array = this.dynamicParser.getSelectedOrgs();			if(orgs.length > 0){				this.xml.appendChild(this.tagGenerator.br());				this.xml.appendChild(this.tagGenerator.br());				this.xml.appendChild(this.tagGenerator.setFormat("code"));				this.xml.appendChild(this.tagGenerator.text("Standards/Frameworks	:"));				this.xml.appendChild(this.tagGenerator.br());				this.xml.appendChild(this.tagGenerator.br());				for each(var org:Array in orgs){					this.xml.appendChild(this.tagGenerator.setFormat("org"));					this.xml.appendChild(this.tagGenerator.text(org[0]));					this.xml.appendChild(this.tagGenerator.setFormat("code")); //No es un code, pero se reutiliza el formato.					this.xml.appendChild(this.tagGenerator.text(" = " + org[1]));					this.xml.appendChild(this.tagGenerator.br());				}			}		}				/**		Metodo protegido que reemplaza los Tags Var por tags <text> con la información dinamica.		**/		protected function replaceDynamicData(){							for each (var node: XML in this.xml.descendants("var")){												node.parent().replace(node.childIndex(), this.tagGenerator.text(dynamicParser.getDataByKey(node.@name)));			}		 							}				/**		Metodo protegido que se encarga del parsing de los datos dinámicos del objeto XML.		**/		protected function parseDynamicSection(xml:XML):XML{						//Se guarda en partNode el nodo <partDefinition>...</partDefinition> del xml.			var partNode:XML = xml.partdefinition[0];			var staticData:XML = new XML("<staticData/>");			//Se elimina el nodo <partDefinition>...</partDefinition> del xml.						delete xml.partdefinition;			dynamicParser = new StandardDynamicParser(xml, orgCodes, this.imgData, this.atoms);							dynamicParser.parseDynamicData();			var dynamicData:XML = dynamicParser.getDynamicData();						//trace(dynamicData.toXMLString());									staticData.appendChild(partNode.part1[0].children());			staticData.appendChild(this.parsePart(dynamicData.Part1[0]).children()); //Part1 en mayúscula porque proviene de StandardDynamicParser.						//MR:			if(partNode.part2[0])			{					staticData.appendChild(partNode.part2[0].children());				staticData.appendChild(this.parsePart(dynamicData.Part2[0]).children());				}									//trace(staticData.toXMLString());						return staticData;		}					/**		Metodo protegido que dado un numbering retorna el siguiente.		Es decir, si recibe "1" retorna, "2". Si recibe "a", retorna "b".		**/		protected function nextNumbering(item:String):String{			if(item == "") 				return item;			if(!isNaN(parseInt(item))){				item = new String(int(item)+1); 			}			else{				item = String.fromCharCode(item.charCodeAt(0)+1);			}						return(item);		}			/**		Metodo protegido que parsea una parte del objeto XML (primero la Parte 1 y luego la Parte 2).		**/		protected function parsePart(xml:XML):XML{						var output: XML = new XML("<part/>");			var categoryNumbering:String="";			var standardNumbering:String="";			var qlNumbering:String="";			var qlNumbAvailable,stNumbAvailable,catNumbAvailable:Boolean;			catNumbAvailable = true;				for each (var category:XML in xml.*){								//Se agrega el tag setFormat si la categoria tiene definido un formato				if(category.attribute("format").length()!=0)					output.appendChild(this.tagGenerator.setFormat(category.attribute("format").toString()));								//Si tiene definido el atributo numbering, se recupera y se setea el tipo de numeracion y se inicializa.				if(category.attribute("numbering").length()!=0  && catNumbAvailable){					categoryNumbering = category.attribute("numbering").toString().toLocaleLowerCase()=="letter" ? "a" : "1";					catNumbAvailable = false;				}								this.tagGenerator.paragraph();				this.tagGenerator.text(categoryNumbering == "" ? category.attribute("text") : categoryNumbering + ". " + category.attribute("text"));				output.appendChild(this.tagGenerator.currentTag());				output.appendChild(this.tagGenerator.br());											categoryNumbering = this.nextNumbering(categoryNumbering);				stNumbAvailable = true;				for each (var standard:XML in category.*){										//Se agrega el tag setFormat si el standard tiene definido un formato					if(standard.attribute("format").length()!=0)						output.appendChild(this.tagGenerator.setFormat(standard.attribute("format").toString()));											//Si tiene definido el atributo numbering, se recupera y se setea el tipo de numeracion y se inicializa.					if(standard.attribute("numbering").length()!=0 && stNumbAvailable){						standardNumbering = standard.attribute("numbering").toString().toLocaleLowerCase()=="letter" ? "a" : "1"; 						stNumbAvailable =false;					}					this.tagGenerator.paragraph();					this.tagGenerator.text(standardNumbering == "" ? standard.attribute("text") : standardNumbering + ". " + standard.attribute("text"));					output.appendChild(this.tagGenerator.currentTag());										standardNumbering = this.nextNumbering(standardNumbering);									qlNumbAvailable = true;										//Loop sobre los OrgCodes.					if(standard.hasOwnProperty("OrgCode")){						trace("org code1");						output.appendChild(this.tagGenerator.setFormat("orgCodes")); //Formato para el párrafo						this.tagGenerator.paragraph();						for each(var oc:XML in standard.OrgCode){							this.tagGenerator.setFormat("org");							this.tagGenerator.text(oc.@org + ": ");							this.tagGenerator.setFormat("code");							this.tagGenerator.text(oc.@code + "; ");						}						var codes:XML = this.tagGenerator.currentTag();						var lastCode:XML = codes.children()[codes.children().length()-1];						lastCode.@txt = String(lastCode.@txt).replace("; ", ".");						output.appendChild(codes);					}										//Loop sobre las QualifierLines.					for each (var ql:XML in standard.ql){						//Se agrega el tag setFormat si la ql tiene definido un formato						if(ql.attribute("format").length()!=0)							output.appendChild(this.tagGenerator.setFormat(ql.attribute("format").toString()));												//Si tiene definido el atributo numbering, se recupera y se setea el tipo de numeracion y se inicializa.						if(ql.attribute("numbering").length()!=0 && qlNumbAvailable){							qlNumbAvailable = false;							qlNumbering = ql.attribute("numbering").toString().toLocaleLowerCase()=="letter" ? "a" : "1";						}												this.tagGenerator.table(0,"left","top","left");						this.tagGenerator.row(null,null);						var imgWidth= 0;						if(ql.attribute("width").length()!=0){							imgWidth = Number(ql.attribute("width").toString())						}						this.tagGenerator.textCell(this.pageWidth - this.pageLeftMargin - this.pageRightMargin - imgWidth, null, "middle");						this.tagGenerator.text(qlNumbering == "" ? ql.attribute("text").toString() : qlNumbering + ". " + ql.attribute("text").toString());											//Si la qualifierLine tiene una imagen asociada se agrega						if(ql.attribute("img").length()!=0){							this.tagGenerator.imageCell(ql.attribute("img").toString(),NaN,"false","left","middle");						}						output.appendChild(this.tagGenerator.currentTag());													qlNumbering = this.nextNumbering(qlNumbering);					}									output.appendChild(this.tagGenerator.br());				}				  			}			return output;					}			}}