package com.kpm.games.game5 {	import com.kpm.common.*;	import com.kpm.kpm.BubbleId;	import com.kpm.games.EGameCharacter;import flash.display.Stage;public class Game5Data extends GameData    {        //THIS SOFTWARE GENERATES A PATH OF mpNumTotalNodesInPath POSITIONS        //STARTING AT mpPathInitialValue        //INITIAL VALUE OF THE PATH        public var mpPathInitialValue              : int;        //Number of Positions or Nodes (Path = [list of Nodes : Pieces+Wholes]        public var mpNumTotalNodesInPath            : int = 0;        //First it puts a random number of numberals between a min and a max        //Then it puts a random number of wholes between a min and a max        //This is the best way to populate the pieces and wholes        //as we have a fine control over the progression        public var mpMinRandomNumAdjacentPieces     : int = 1;        public var mpMaxRandomNumAdjacentPieces     : int = 2;        public var mpMaxRandomNumAdjacentWholes     : int = 2;        public var mpMinRandomNumAdjacentWholes     : int = 3;        //Present objects at random from the hole set        public var mpNumAnswersToChoose               : uint = 3;        public var mpNumPresentations                 : uint = 6;        public var mGameObjects : Array = new Array();        public var mWholes : Array = new Array();        public var mAnswerBoxCounters : Array = new Array();        public var mNodes : Array = new Array();	    public static const CARD_CRESCENDO 		: String = "CRESCENDO";        public static const CARD_DECRESCENDO 		: String = "DECRESCENDO";        public static const GAME_OBJ_PER_PLATFORM 		: int = 10;        public static const gameCharacterNames : Array = ["Frog,Bird,Bee,Mouse"]        public static const ANSWER_BOX_POSITION    : Array = [400,700];        public static const ANSWER_BOX_SIZE        : Array = [424,156];        public static const COUNTERS_HEIGHT : int = 155;        public function Game5Data(pBubble : BubbleId, pLanguage : ELanguage, pGame : Object, pChar : EGameCharacter){            super(pBubble, pLanguage, pGame);		    initGameGoalAndParameters();		    soundLibrary.createLibrary(pLanguage, gameId, pChar, pBubble.Name);        }            //Actualiza variables para cada bubble usando el quality, Bubble.Name y Bubble.Level        private function initGameGoalAndParameters(){            Util.debug("Game5.defineBubbleVars");            Util.debug("splitting parameters " + Bubble.Text.split("_")[0] + " " + Bubble.Text.split("_")[1] + " " + Bubble.Text.split("_")[2]);            super.updateGoal();            gameGoal = new Goal(mpNumPresentations, EGoal.PLACE_NUMBER);            if(gameGoal.quality == EGoal.PLACE_NUMBER){                //Bubble Vars for PlaceNumber bubbles                mpNumTotalNodesInPath = Bubble.Text.split("_")[1];                mpPathInitialValue = Bubble.Text.split("_")[2];                Util.printArray(["numTotalNodes: ", mpNumTotalNodesInPath, "firstNumber : ", mpPathInitialValue],  "deifineGoal")                if(Bubble.Name.Text.indexOf("PlaceNumber") != -1){                    switch(Bubble.Level){                        case 1: break;                    }                }            }        }		//$ update the variables that change per task.		public function updateGameGoal(pGoal : Number){            Util.debug("Game5.updateGameGoal")			var i=0;						do			{				switch (gameGoal.quality)                {					case EGoal.PLACE_NUMBER: 	 CurrentGoal = pGoal; break;				}				i++;			}			while (gameGoal.currentGoal == gameGoal.pastGoal && i < 10);						gameGoal.pastGoal = gameGoal.currentGoal;			//*starts a task/round			resetTask();            taskTimer.start();            simulateMouseMoving();		}        //SCORING????        //for now scoring is done based on path or based on choice.        //should we have a new way of        // pType        public function generateGroup(pFirstNumber : int, pType : EG5PieceType, pHowMany : int)        {            var nodes : Array = new Array();                          -            Util.debug("Generating Group of " + pHowMany);            for (var i=0; i < pHowMany; i++)            {                nodes.push(new Object());                nodes[i].whole = (pType == EG5PieceType.WHOLE);                nodes[i].index = mNodes.length + i + 1;                nodes[i].numeral = pFirstNumber + i + 1;                with (nodes[i]){Util.printArray(["nodes[i]: .whole : ", whole, ", .index : " , index , ", .numeral : " , numeral] , "generateGroup") ; }            }            return nodes;        }        public function addNodesToPath(pNodes : Array) : int        {            for(var i = 0; i < pNodes.length; i++)                mNodes.push(pNodes[i]);            Util.printArray(pNodes, "addNodesToPath");            return pNodes.length;        }        public function colorPiece(pGC : GameComponent, pColor : EColor )        {            Util.printArray(["pGC.numeral", pGC.numeral], "G5Data.colorPiece");            if(pGC.numeral%5 == 0)                pGC.ColorAll = EColor.Green;            else if(pColor != null)                pGC.ColorAll = pColor;            else throw ("pColor is null G5Data.colorPiece");        }		//Este método permite actualizar la meta. Tiene sentido para el caso de bubble ChangePlus al momento de llevar a cabo la segunda pregunta		public function updateCurrentGoal(newGoal : Number)        {			gameGoal.currentGoal = newGoal;		}    }}