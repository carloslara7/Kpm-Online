package com.kpm.games.game5 {	import com.kpm.common.*;	import com.kpm.kpm.BubbleId;	import com.kpm.games.EGameCharacter;import flash.display.Stage;import flash.events.Event;public class Game5Data extends GameData    {        //THIS SOFTWARE GENERATES A PATH OF mpNumTotalNodesInPath POSITIONS        //STARTING AT mpPathInitialValue        //INITIAL VALUE OF THE PATH        public const mpPathInitialValue              : int = 0;        //Number of Positions or Nodes (Path = [list of Nodes : Pieces+Wholes]        public const mpNumTotalNodesInPath            : int = 1;        //Present objects at random from the hole set        public const mpNumAnswersToChoose               : uint = 2;        public const mpNumPresentations                 : uint = 3;        //First it puts a random number of numberals between a min and a max        //Then it puts a random number of wholes between a min and a max        //This is the best way to populate the pieces and wholes        //as we have a fine control over the progression        public const mpMinRandomAdjacentPieces : int = 4;        public const mpMaxRandomNumAdjacentPieces     : int = 5;        public const mpMaxRandomNumAdjacentWholes     : int = 6;        public const mpMinRandomNumAdjacentWholes     : int = 7;        public const mpOrder     : int = 8;        public var mGameObjects : Array;        public var mWholes : Array;        public var mAnswerBoxCounters : Array;        public var mNodes : Array;        public static const ANSWER_BOX_POSITION    : Array = [420,700];        public static const ANSWER_BOX_SIZE        : Array = [424,156];        public static const COUNTERS_HEIGHT : int = 155;        public function Game5Data(pBubble : BubbleId, pLanguage : ELanguage, pGame : Object, pChar : EGameCharacter){            super(pBubble, pLanguage, pGame);            if(mGameObjects) mGameObjects.splice(0);            else mGameObjects = new Array();            if(mNodes)mNodes.splice(0);            else mNodes = new Array();            if(mWholes)mWholes.splice(0);            else mWholes = new Array();            mAnswerBoxCounters = new Array();		    initGameGoal();		    soundLibrary.createLibrary(pLanguage, gameId, pChar, pBubble.Name);        }        public override function  onRemove(e : Event)        {            if(mGameObjects) mGameObjects.splice(0);            if(mNodes)mNodes.splice(0);            if(mWholes)mWholes.splice(0);        }            //Actualiza variables para cada bubble usando el quality, Bubble.Name y Bubble.Level        private function initGameGoal(){            Util.debug("Game5.defineBubbleVars");            Util.debug("splitting parameters " + Bubble.Text.split("_")[0] + " " + Bubble.Text.split("_")[1] + " " + Bubble.Text.split("_")[2]);            super.updateGoal();            gameGoal = new Goal(mpNumPresentations, EGoal.PLACE_NUMBER);            if(gameGoal.quality == EGoal.PLACE_NUMBER){                //Bubble Vars for PlaceNumber bubbles                //mpNumTotalNodesInPath = Bubble.Text.split("_")[1];                //mpPathInitialValue = Bubble.Text.split("_")[2];                Util.printArray(["numTotalNodes: ", mpNumTotalNodesInPath, "firstNumber : ", mpPathInitialValue],  "deifineGoal")                if(Bubble.Name.Text.indexOf("PlaceNumber") != -1){                    switch(Bubble.Level){                        case 1: break;                    }                }            }        }		//$ update the variables that change per task.		public function updateGameGoal(pGoal : Number){            Util.debug("Game5.updateGameGoal")			var i=0;						do			{				switch (gameGoal.quality)                {					case EGoal.PLACE_NUMBER: 	 CurrentGoal = pGoal; break;				}				i++;			}			while (gameGoal.currentGoal == gameGoal.pastGoal && i < 10);						gameGoal.pastGoal = gameGoal.currentGoal;			//*starts a task/round			resetTask();            taskTimer.start();            simulateMouseMoving();		}        public function outputParameters()        {            Util.printArray(["mpPathInitialValue", GameData.params[0],                            "mpNumTotalNodesInPath", GameData.params[1],                            "mpNumAnswersToChoose : ", GameData.params[2],                            "mpNumPresentations : ", GameData.params[3],                            "mpMaxRandomNumAdjacentPieces", params[4],                            "mpMinRandomNumAdjacentPieces",params[5],                            "mpMaxRandomNumAdjacentWholes", params[6],                            "mpMinRandomNumAdjacentWholes",params[7],                            "mpOrder",params[8]],                            "Initializing Parameters");        }        //SCORING????        //for now scoring is done based on path or based on choice.        //should we have a new way of        // pType        public function generateGroup(pFirstNumber : int, pType : EG5PieceType, pHowMany : int)        {            var nodes : Array = new Array();                          -            Util.debug("Generating Group of " + pHowMany);            for (var i=0; i < pHowMany; i++)            {                nodes.push(new Object());                nodes[i].whole = (pType == EG5PieceType.WHOLE);                    nodes[i].index = mNodes.length + i + 1;                nodes[i].numeral = pFirstNumber + i;                with (nodes[i]){Util.printArray(["nodes[i]: .whole : ", whole, ", .index : " , index , ", .numeral : " , numeral] , "generateGroup") ; }            }            return nodes;        }            public function newCounter(index : int, numeral : int, stage : Stage, pArray : Array)        {            Util.debug("G5Data.newCounter");            var counter : Counter = new Counter(Counter.getNumberForm(bubble), numeral, stage);            pArray[index] = new GameComponent();            pArray[index].MovieName = "BoxCoverGray";            pArray[index].addMovieClip(counter, false, -100);            pArray[index].feedbackSound = ENumber.getEnum(pArray[index].secondMovie.numeral).Text;            pArray[index].x = Game5Data.ANSWER_BOX_POSITION[Util.INDEX_X] + (index* 115);            pArray[index].y = Game5Data.ANSWER_BOX_POSITION[Util.INDEX_Y];            pArray[index].scaleX *= 0.7;            pArray[index].scaleY *= 0.8;            colorPiece(pArray[index], EColor.Blue, mNodes[index].numeral);        }        public function addNodesToPath(pNodes : Array) : int        {            for(var i = 0; i < pNodes.length; i++)                mNodes.push(pNodes[i]);            Util.printArray(pNodes, "addNodesToPath");            return pNodes.length;        }        public function colorPiece(pGC : GameComponent, pColor : EColor, numeral : int)        {            Util.printArray(["pGC.numeral", numeral], "colorPiece");            scalePiece(pGC,  numeral);            if((numeral % 10) == 0)                pGC.ColorAll = EColor.Yellow;            else if((numeral % 5) == 0)                pGC.ColorAll = EColor.Orange;            else if(pColor != null)                pGC.ColorAll = pColor;            else throw ("pColor is null colorPiece");        }    public function scalePiece(pGC : GameComponent, numeral : int)    {        Util.printArray(["pGC.numeral", numeral], "scalePiece");        if((numeral % 10) == 0)            pGC.Movie.Scale *= 1.5;        else if((numeral % 5) == 0)            pGC.Movie.Scale *= 1.2;    }		//Este método permite actualizar la meta. Tiene sentido para el caso de bubble ChangePlus al momento de llevar a cabo la segunda pregunta		public function updateCurrentGoal(newGoal : Number)        {			gameGoal.currentGoal = newGoal;		}    }}