package com.kpm.games{	import com.kpm.common.EColor;	import com.kpm.common.GameData;	import com.kpm.common.KpmShape;	import com.kpm.common.MovieList;	import com.kpm.common.Point2D;	import com.kpm.common.Util;		import flash.display.*;		public class Game2ShapeList extends MovieList 	{		public var puzzleShapeTypes			: Array;		protected var distractorShapes  	: Array;		protected var g2					: Game2;		protected var maxDistractorHeight	: Number;		protected var maxWidth	: Number;		public var chosenShape;				public static const DISTRACTORS_IN_PUZZLE 			: int = 1;		public static const DISTRACTORS_SIMILAR_TO_PUZZLE 	: int = 2;		public static const	DISTRACTORS_ANY_ALLOWED_TYPE 	: int = 3;		public static const DISTRACTORS_SIMILAR_TO_ANSWER 	: int = 4;				public function Game2ShapeList(pObject : Object, pShapeTypes : Array, pGame2 : Game2)		{			super(true, pObject.between.y, 0, pObject.min, pObject.max);			maxDistractorHeight = pObject.maxDistractorHeight;				maxWidth = pObject.max.x;					puzzleShapeTypes = pShapeTypes;			g2 = pGame2;						Util.debug(maxDistractorHeight, this);			Util.debug(max, this);			//Util.debug(MinHeight, this);			//Util.debug(FixedHeight, this);					}						public function generateShapes(	pChosenShape : KpmShape, 										pNumOptions  : uint = 3)		{			init();			Util.debug("current puzzle " + g2.CurrentPuzzle.Puzzle);			Util.debug("game2shapeslist.generateShapes with ");			Util.debug("choosenShape " + pChosenShape + " " + pNumOptions);			var index : uint;			distractorShapes  = new Array();			var temp : Number ;						var numOptions : uint = pNumOptions-1;			if(pChosenShape.attempts > 0)				numOptions--;					chosenShape = Util.createMc(pChosenShape.Type);		 	chosenShape.transform = pChosenShape.transform; 						if(g2.G2Data.lvl_PlaceShape)			{				chosenShape.tFill.transform.colorTransform = Util.generateColorTransform(GameData.colorsRGB[EColor.Black.Text]);				g2.CurrentPuzzle.addToUsedShapes(pChosenShape);							}			else				Util.copyColor(pChosenShape.tFill,chosenShape.tFill);						Util.debug("changing rotation of choosen shape" + g2.G2Data.lvl_DistractorRotation);						if(g2.G2Data.lvl_DistractorRotation)				chosenShape.rotation = Util.getRandomAngleBetween(25,90);			else				Util.copyRotation(pChosenShape, chosenShape);									addShape(chosenShape);			g2.CurrentPuzzle.addToUsedShapes(pChosenShape);			addToDistractors(pChosenShape.Type);			addToDistractors("KpmShape");									if(g2.G2Data.lvl_PlaceShape && g2.G2Data.lvl_DistractorType != Game2ShapeList.DISTRACTORS_IN_PUZZLE)			{				g2.CurrentPuzzle.generateRepeatedShapes();					for (var type : String in g2.CurrentPuzzle.repeated2Shapes)					if(g2.CurrentPuzzle.repeated2Shapes[type].length >= 3)						addToDistractors(type);			}						//chosenShape.tFill.transform.colorTransform = Util.randomColorTransform();						for(var i=0; i< numOptions; i++)			{				Util.debug("i " + i );				makeDistractor(pChosenShape);							}						if(g2.G2Data.lvl_DistractorType != Game2ShapeList.DISTRACTORS_IN_PUZZLE)			{					if(g2.G2Data.lvl_DistractorType != Game2ShapeList.DISTRACTORS_SIMILAR_TO_PUZZLE)					makeAllSimilarSize(0);				if(g2.G2Data.lvl_PlaceShape)					checkSimilarSizeInPuzzle(0);								if(!g2.G2Data.lvl_PlaceShape || g2.G2Data.lvl_DistractorType != Game2ShapeList.DISTRACTORS_SIMILAR_TO_PUZZLE)					fixHeightAndWidth(0);																}												//makeDistractorsSmall(0);						shuffleMovieList();						for (var j =  MovieArray.length - 1 ; j >= 0 ; j--)			{					if(Util.getClassName(MovieArray[j]) == "ThirtyRightTriangle")				{					MovieArray[j].y += MovieArray[j].height/3.5; 					}			}						distributeEvenly(Game2Data.OPTIONS_MAX_HEIGHT);									}				public function makeDistractor(pChosenShape : KpmShape)		{			var type : String = "";			var tempShape,tempShape1 : MovieClip;						Util.debug("type of distractors is " + g2.G2Data.lvl_DistractorType);						if(g2.G2Data.lvl_DistractorType <= 2)			{				var i =0;				do				{					Util.printArray(distractorShapes);					i++;//					if(g2.G2Data.lvl_DistractorType == DISTRACTORS_IN_PUZZLE)//					{						if(g2.CurrentPuzzle.Puzzle.numChildren > MovieArray.length)						{							tempShape = g2.CurrentPuzzle.getRandomShape();							type = tempShape.Type;						}						else						{							i = 20;							tempShape = new KpmShape();						}//					}	//					else//					{//						//if(i < 15)//						//{//							tempShape = g2.CurrentPuzzle.getRandomShape();//							type = tempShape.Type;//						//}//						//else//						//	type = Util.getRandomElementNotIn(Game2Data.simShapes[pChosenShape.Type], distractorShapes) as String;//					}															Util.debug("trying for the " + i + "th time to make distractor - type " + type);					Util.debug("height " + (height + tempShape.height + 40));									}				while( i < 50 && 				((height + tempShape.height + 40 >= 550 && g2.G2Data.lvl_DistractorType == DISTRACTORS_IN_PUZZLE) ||				(Util.searchInArray(distractorShapes, type) && (g2.G2Data.lvl_DistractorType == DISTRACTORS_SIMILAR_TO_PUZZLE || (g2.G2Data.lvl_DistractorType == DISTRACTORS_IN_PUZZLE && i < 10)))));				//while the shape has not been used instead of type								if(i == 50)					type = "";			}						else if(g2.G2Data.lvl_DistractorType == DISTRACTORS_ANY_ALLOWED_TYPE)				type = Util.getRandomElementNotIn(puzzleShapeTypes, distractorShapes) as String;			else if(g2.G2Data.lvl_DistractorType == DISTRACTORS_SIMILAR_TO_ANSWER)				type = Util.getRandomElementNotIn(Game2Data.simShapes[pChosenShape.Type], distractorShapes) as String;						if(type != "")			{				Util.debug(type + " chosen as distractor for " + pChosenShape.Type, this);				tempShape1 = Util.createMc(type);								if(g2.G2Data.lvl_DistractorType == DISTRACTORS_IN_PUZZLE)				{					tempShape1.transform = tempShape.transform;					tempShape1.x = 0;									}								else if(g2.G2Data.lvl_DistractorType == DISTRACTORS_SIMILAR_TO_PUZZLE)				{					if(g2.CurrentPuzzle.repeated2Shapes[type])					{						Util.debug("getting scale for tempshape " + type);						Util.debug(g2.CurrentPuzzle.repeated2Shapes[type].length);						var newScale, newScaleX, newScaleY : Number ; 						var random : Number;						if(g2.CurrentPuzzle.repeated2Shapes[type].length == 2)						{							random =   Util.getRandBtwF(0.9,1.1)							newScaleX = random*(Math.abs(g2.CurrentPuzzle.repeated2Shapes[type][0].scaleX) + Math.abs(g2.CurrentPuzzle.repeated2Shapes[type][1].scaleX))/2							newScaleY = random*(Math.abs(g2.CurrentPuzzle.repeated2Shapes[type][0].scaleY) + Math.abs(g2.CurrentPuzzle.repeated2Shapes[type][1].scaleY))/2							Util.debug("new sizes " + newScaleX + " " + newScaleY);														Util.debug(g2.CurrentPuzzle.repeated2Shapes[type][0] + " " + g2.CurrentPuzzle.repeated2Shapes[type][1])							tempShape1 = Util.changeMovieSize(tempShape1 , newScaleX, newScaleY); 						}						else if(g2.CurrentPuzzle.repeated2Shapes[type].length == 1)						{							random = Util.getRandBtw(0,1) ? Util.getRandBtwF(1 + g2.G2Data.lvl_size1, 1 + g2.G2Data.lvl_size1 + g2.G2Data.lvl_size2) : Util.getRandBtwF(1 - g2.G2Data.lvl_size1 - g2.G2Data.lvl_size2, 1 - g2.G2Data.lvl_size1);							newScaleX = g2.CurrentPuzzle.repeated2Shapes[type][0].scaleX *random;							newScaleY = g2.CurrentPuzzle.repeated2Shapes[type][0].scaleY *random;							 							tempShape1 = Util.changeMovieSize(tempShape1 , newScaleX, newScaleY);							Util.debug("new sizes " + newScaleX + " " + newScaleY);														if(tempShape1.height < 40 || tempShape1.width < 40)							{																newScale = g2.CurrentPuzzle.repeated2Shapes[type][0].scaleX*(1/newScaleX) * Util.getRandBtwF(1 + g2.G2Data.lvl_size1, 1 + g2.G2Data.lvl_size1 + g2.G2Data.lvl_size2);								tempShape1 = Util.changeMovieSize(tempShape1 , newScale);								Util.debug("tempshape1 too small " + newScale);							}							else if (tempShape1.height > 170 || tempShape1.width > 220)							{								newScale = g2.CurrentPuzzle.repeated2Shapes[type][0].scaleX*(1/newScaleX) * Util.getRandBtwF(1 - g2.G2Data.lvl_size1 - g2.G2Data.lvl_size2, 1 - g2.G2Data.lvl_size1);								tempShape1 = Util.changeMovieSize(tempShape1 , newScale);								Util.debug("tempshape1 too big " + newScale);							}														Util.debug("scale of model " + g2.CurrentPuzzle.repeated2Shapes[type][0]);						}						else if(g2.CurrentPuzzle.repeated2Shapes[type].length >= 3)							throw new Error("distractor of different scale is more than 3.");																				Util.debug("changing movie size " + tempShape1.height + " " + tempShape1.width);									}																								//var oldScale : Number = getRealScale(tempShape)/getRealScale(tempShape1);										//Util.debug("changing movie size " + tempShape1.height + " " + tempShape1.width + " " + oldScale + " " + newScale);					//tempShape1.scaleX = tempShape1.scaleX*oldScale;					//tempShape1.scaleY = tempShape1.scaleY*oldScale;										}				 				if(g2.G2Data.lvl_DistractorRotation)					tempShape1.rotation = Util.getRandomAngleBetween(25,90);				else if(g2.G2Data.lvl_DistractorType == DISTRACTORS_IN_PUZZLE || g2.G2Data.lvl_DistractorType == DISTRACTORS_SIMILAR_TO_PUZZLE)					Util.copyRotation(tempShape, tempShape1);								if(g2.G2Data.lvl_PlaceShape)					tempShape1.tFill.transform.colorTransform = Util.generateColorTransform(GameData.colorsRGB[EColor.Black.Text]);				else					tempShape1.tFill.transform.colorTransform = 						pChosenShape.tFill.transform.colorTransform;										Util.debug("adding distractor " + type);					distractorShapes.push(type);				addShape(tempShape1);								if(g2.G2Data.lvl_PlaceShape)					g2.CurrentPuzzle.addToUsedShapes(tempShape);												}		}				public function hitShape(pShape : MovieClip) : MovieClip		{			addChild(pShape);			var movieArray 	: Array = hitMovies(pShape);			removeChild(pShape);						Util.debug("ShapeList.hitShape");			Util.printArray(movieArray);						for(var i=0; i < movieArray.length; i++)			{				if(Util.getClassName(movieArray[i]) == Util.getClassName(pShape))						return movieArray[i];			}						for(i=0; i < movieArray.length; i++)			{				return movieArray[i];			}						return null;		}				public function addToDistractors(pType : String)		{			Util.debug("addtoDistractors " + pType);			if(g2.G2Data.lvl_DistractorType != Game2ShapeList.DISTRACTORS_ANY_ALLOWED_TYPE)				distractorShapes.push(pType);			else			{				for(var item in puzzleShapeTypes)				{					Util.debug("looping " + puzzleShapeTypes[item], this);					if(KpmShape.getShortType(puzzleShapeTypes[item]) == 					   KpmShape.getShortType(pType))					{						Util.debug("pushing to distractor " + puzzleShapeTypes[item], this);						distractorShapes.push(puzzleShapeTypes[item]);					}				}			}		}				public function fixHeightAndWidth(pChosenIndex : int)		{			var remainingHeight = 550 - MovieArray[pChosenIndex].height;			var maxHeightPerDistractor = remainingHeight/2 - 40; 			var scalingFactor : Number;						for (var i =  MovieArray.length - 1 ; i >= 0 ; i--)			{				Util.debug("Fixing height and width" + MovieArray[i]  + " height " + MovieArray[i].height, this);				if(MovieArray[i].height > maxHeightPerDistractor && i != pChosenIndex)				{					Util.debug("making smaller", this);					scalingFactor = (maxHeightPerDistractor/MovieArray[i].height)*Util.getRandBtwF(0.9,1.1);					MovieArray[i] = Util.changeMovieSize(MovieArray[i], scalingFactor);					Util.debug("height " + MovieArray[i].height, this);				} 				//				if(MovieArray[i].height > maxDistractorHeight && i != pChosenIndex)//				{//					Util.debug("making smaller", this);//					MovieArray[i] = Util.changeMovieSize(MovieArray[i], 0.75);//					Util.debug("height " + MovieArray[i].height, this);//				} 								if(MovieArray[i].width >  maxWidth && i != pChosenIndex)				{					Util.debug("making smaller", this);					scalingFactor = (maxWidth/MovieArray[i].width)*Util.getRandBtwF(0.9,1.1);;					MovieArray[i] = Util.changeMovieSize(MovieArray[i], scalingFactor);					Util.debug("width " + MovieArray[i].width, this);				}								if(MovieArray[i].height < 40 && i != pChosenIndex)				{					Util.debug("making bigger", this);					scalingFactor = (40/MovieArray[i].height)*Util.getRandBtwF(0.9,1.1);					MovieArray[i] = Util.changeMovieSize(MovieArray[i], scalingFactor);					Util.debug("height " + MovieArray[i].height, this);				} 												if(MovieArray[i].width < 40 && i != pChosenIndex)				{					Util.debug("making bigger", this);					scalingFactor = (40/MovieArray[i].width)*Util.getRandBtwF(0.9,1.1);;					MovieArray[i] = Util.changeMovieSize(MovieArray[i], scalingFactor);					Util.debug("width " + MovieArray[i].width, this);				}											}					}				public function makeAllSimilarSize(pChosenIndex : int)		{					var scaleDistractor, smallFactor : Number;			Util.debug("scale shapes " + Game2Data.scaleShapes[Util.getClassName(MovieArray[pChosenIndex])], this);			Util.debug("scale chosen X" + MovieArray[pChosenIndex].scaleX, this);			Util.debug("scale chosen Y" + MovieArray[pChosenIndex].scaleY, this);			Util.debug("name " +Util.getClassName(MovieArray[pChosenIndex]), this);						for (var i =  MovieArray.length - 1 ; i >= 0 ; i--)			{				if(i != pChosenIndex)				{					Util.debug("name " +Util.getClassName(MovieArray[i]), this);					smallFactor = getRealScale(MovieArray[pChosenIndex])/getRealScale(MovieArray[i]);					Util.debug("smallFactor " + smallFactor + MovieArray[i], this);					MovieArray[i] = Util.changeMovieSize(MovieArray[i], smallFactor);				}//				//				if(Util.getClassName(MovieArray[i]) == "ThirtyRightTriangle")//				{//					Util.debug("q pexxxxxxx", this);//					MovieArray[i].y += MovieArray[i].height/3; //					//				}			}						Util.debug("height is " + height);		}				public function getRealScale(pMovie : MovieClip)		{			var type : String;			if(pMovie is KpmShape)				type = pMovie.Type;			else				type = Util.getClassName(pMovie);							Util.debug("ShapeList.getRealScale " + pMovie + " " + type + " " + Game2Data.scaleShapes[type]);			return (Math.abs(pMovie.scaleX)/2 + Math.abs(pMovie.scaleY)/2)*Game2Data.scaleShapes[type]		}				public function makeDistractorsSmall(pChosenIndex : int)		{			//TODO : change heightxwidth to be the same			var smallFactor : Number;						if(MovieArray[pChosenIndex].height < 100)			{				Util.debug("making distractors small", this);				for (var i =  MovieArray.length - 1 ; i >= 0 ; i--)				{					if(i != pChosenIndex)					{						smallFactor = MovieArray[pChosenIndex].height/MovieArray[i].height;						Util.debug("smallFactor " + smallFactor, this);						MovieArray[i] = Util.changeMovieSize(MovieArray[i], smallFactor);					}				}			}					}				public function checkSimilarSizeInPuzzle(pChosenIndex : int)		{			Util.debug("ShapeList.checkSimilarSize");						for (var i =  MovieArray.length - 1 ; i >= 0 ; i--)			{				if(i != pChosenIndex)				{					Util.debug("size of " + i + " " + MovieArray[i].height + " " + MovieArray[i].width)										var shapesOfType : Array = g2.CurrentPuzzle.getShapesOfType(MovieArray[i].Type);					Util.debug("scale of distractor " + MovieArray[i].scaleX + " " + MovieArray[i].scaleY);										for(var j=0; j < shapesOfType.length; j++)					{						Util.debug("scale of shape of type " + shapesOfType[j].scaleX + " " + shapesOfType[j].scaleY);					}										for(var j=0; j < shapesOfType.length; j++)					{						Util.changeSimilarScales(MovieArray[i], shapesOfType[j], 15, new Point2D(30, 30) , new Point2D(220,170), g2.G2Data.lvl_size1, g2.G2Data.lvl_size2)					}				}			}									return false;		}				public function addShape(pShape : MovieClip)		{			pShape.Type = Util.getClassName(pShape);			add(pShape);		}			}}