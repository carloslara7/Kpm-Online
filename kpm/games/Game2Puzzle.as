package com.kpm.games{	import com.kpm.common.*;		import flash.display.MovieClip;	import flash.events.*;		public class Game2Puzzle extends GameComponent	{				private var candidateShapeList	: Array;		private var numShapes			: uint;		private var usedShapes 			: Array;		public var repeated2Shapes : Array ;				public function Game2Puzzle(pPosition : Point2D, pPuzzleName : String)		{			super();			x = pPosition.x;			y = pPosition.y;						MovieName = pPuzzleName;			addChild(Movie);            Movie.tMask.gotoAndStop(1);					}				function initialize()		{					candidateShapeList = new Array();			numShapes = Puzzle.numChildren;									var tempShape    	: KpmShape;			var stageShape		: MovieClip;						for(var i=0; i < Puzzle.numChildren; i++) 			{     				stageShape = Puzzle.getChildAt(i)  as MovieClip;				if(identifyShape(stageShape))				{					tempShape = KpmShape.makeShape(stageShape);					stageShape.visible = false;					Puzzle.addChild(tempShape);										candidateShapeList.push(tempShape);   				}			}						var invisibleArray : Array = new Array();						for(var j=0; j < Puzzle.numChildren; j++) 			{				stageShape = Puzzle.getChildAt(j)  as MovieClip;				if(!stageShape.visible)					invisibleArray.push(stageShape);			}						for (var item in invisibleArray)			{				Puzzle.removeChild(invisibleArray[item]);				}											}				public function paintPuzzleShapes(pColorArray : Array, bBlack : Boolean = false)		{			var stageShape : MovieClip;			var usedColors : Array = new Array();						for(var i=0; i < Puzzle.numChildren; i++) 			{     				stageShape = Puzzle.getChildAt(i)  as MovieClip;				if(bBlack)					var ecolor : EColor = EColor.Black;				else					var ecolor : EColor = Util.getRandomElementNotIn(GameData.ecolors, usedColors) as EColor;												stageShape.paintFill(ecolor);				usedColors.push(ecolor);								if(usedColors.length == GameData.ecolors.length)					usedColors = new Array();							}		}				public function getRandomShape() : KpmShape		{			Util.debug("Util.getRandomShape");			var tempShape : KpmShape ;			Util.printArray(usedShapes);						var i=0;						do {				tempShape = Puzzle.getChildAt(Util.getRandBtw(0, Puzzle.numChildren-1)) as KpmShape;				Util.debug("candidate " + tempShape.Movie);				i++;			}			while(Util.searchInArray(usedShapes, tempShape) && i < 30)							Util.debug("chosen " + tempShape.Movie);			return tempShape;				}				public function addToUsedShapes(pShape : KpmShape)		{			if(!usedShapes)				usedShapes = new Array();							usedShapes.push(pShape);		}				public function resetUsedShapes()		{			usedShapes = new Array();		}		public static function identifyShape(pStageMovie : MovieClip) : Boolean		{			var type = Util.getClassName(pStageMovie);			//Util.debug("making a " + type, this);						if(type == "KpmShape")				return false;			else 				return true;		}				public function countShapes(pType : *, pGoal : EGoal) : uint		{			var counter = 0;			var stageShape : KpmShape;			var quality : String;						for(var i=0; i < Puzzle.numChildren; i++) 			{     				stageShape = Puzzle.getChildAt(i)  as KpmShape;				Util.debug(pType, this);				Util.debug(stageShape.getShortType(), this);				if(pGoal == EGoal.COLOR)					quality = stageShape.color.Text;				if(pGoal == EGoal.SHAPE)					quality = stageShape.getShortType();									if(!pType.Text)					Util.debug("hay pexes", this);									if(quality == pType.Text)				{					counter++;   				}			}							return counter;		}				public function getShapesOfType(pType : String) : Array		{			var counter = 0;			var stageShape : KpmShape;			var shapesOfType : Array = new Array();			Util.debug("finding shapes of type " + pType);						for(var i=0; i < Puzzle.numChildren; i++) 			{     				stageShape = Puzzle.getChildAt(i)  as KpmShape;				Util.debug(stageShape.getShortType(), this);												if(stageShape.Type == pType || (stageShape.Type == "ThirtyRightTriangle" && pType == "AcuteIsoTriangle") || (stageShape.Type == "AcuteIsoTriangle" && pType == "ThirtyRightTriangle")) 				{					shapesOfType.push(stageShape);					//Util.debug("counting shapes +1", this);   				}			}							return shapesOfType;		}//		//		public function countShapesOfColor(pColor : Object) : uint//		{//			var counter = 0;//			var stageShape : KpmShape;//			//			if(!(pColor is Color))//				return;//				//			Util.debug("counting colors" , this);//			//			for(var i=0; i < Puzzle.numChildren; i++) //			{     //				stageShape = Puzzle.getChildAt(i)  as KpmShape;//				Util.debug(pColor, this);//				Util.debug(stageShape, this);//				Util.debug(stageShape.color, this);//				//				if(stageShape.color.equals(pColor))//				{//					counter++;//					//Util.debug("counting shapes +1", this);   //				}//			}	//			//			return counter;//		}						public function intersect(pCoord : Point2D, pRadius : int, pCurrentShape : KpmShape) : MovieClip		{			var shapeHit : MovieClip;			var shape : KpmShape;						Util.debug("Game2Puzzle.intersect " + pCoord + " " + pRadius + " " + pCurrentShape);			for(var i=0; i < Puzzle.numChildren; i++) 			{				shapeHit = intersect1(pCoord, pRadius, Puzzle.getChildAt(i) as KpmShape) as KpmShape;								if(shapeHit && Util.sameClass(shapeHit.Movie, pCurrentShape.Movie) &&  Util.checkSimilarScales(shapeHit, pCurrentShape, 5) != 0)				{										Util.debug("shape hit " + shapeHit);					if(shapeHit)						return shapeHit;				}			}						for(var i=0; i < Puzzle.numChildren; i++) 			{				shape = Puzzle.getChildAt(i) as KpmShape;				shapeHit = intersect1(pCoord, pRadius, shape);				Util.debug("shape hit " + shapeHit);				if(shapeHit)					return shapeHit;			}						return null;		}				public function intersect1(pCoord : Point2D, pRadius : int, pShape : KpmShape) : MovieClip		{			Util.debug("Game2Puzzle.intersect1" + pCoord + " " + pRadius + " " + pShape);			//var debugPoint : MovieClip = new DebugPoint();											if(pShape.hitTestPoint(pCoord.x, pCoord.y, true))			{//				debugPoint.x = pCoord.x;//				debugPoint.y = pCoord.y;//				parent.addChild(debugPoint);							Util.debug("hit " + pShape);				return pShape as MovieClip;			}											for(var i : int  = -1; i <= 1; i++)			{				for(var j : int  = -1; j <= 1; j++)				{										if(pShape.hitTestPoint(pCoord.x + i*pRadius, pCoord.y + j*pRadius, true))					{//						debugPoint = new DebugPoint();//						debugPoint.x = pCoord.x + i*pRadius;//						debugPoint.y = pCoord.y + j*pRadius;//						parent.addChild(debugPoint);											Util.debug("hit " + pShape);						return pShape as MovieClip;					}				}			}						return null						}				public function get ShapesTypesLeft() : Array				{			var shapesLeft : Array			for(var i=0; i < Puzzle.numChildren; i++) 			{				var shape : KpmShape = Puzzle.getChildAt(i) as KpmShape;				shapesLeft.push(shape.Type);			}						return shapesLeft;						}				public function generateRepeatedShapes() : Array				{			Util.debug("Game2Puzzle.TypesOfRepeatedShapes");			repeated2Shapes = new Array();			var repeatedShapes : Boolean = false;						for(var i=0; i < Puzzle.numChildren; i++) 			{				var type : String = (Puzzle.getChildAt(i) as KpmShape).Type;				repeated2Shapes[type] = new Array();							}										for(var i=0; i < Puzzle.numChildren; i++) 			{				var shape : KpmShape = Puzzle.getChildAt(i) as KpmShape;				var type : String = shape.Type;				var tempRotation = shape.rotation;				Util.debug("scale for shape " + shape + " is " + shape.scaleX);				shape.rotation = 0;				var scaleX : Number = Math.abs(shape.scaleX);				repeatedShapes = false;								for(var j=0; j< repeated2Shapes[type].length; j++)					if(Util.round(repeated2Shapes[type][j].scaleX,2) == Util.round(scaleX,2))						repeatedShapes = true;									if(!repeatedShapes)				{					Util.debug("pushing scaleX " + scaleX)					repeated2Shapes[type].push(shape);				}								shape.rotation = tempRotation;							}												for (var type : String in repeated2Shapes)			{				Util.debug("repeated shapes " + type);				Util.printArray(repeated2Shapes[type]);			}						return repeated2Shapes;						}								public function eraseShapesOfType(pType : String)		{			var stageShape : MovieClip;			var array : Array = new Array;			//Util.debug("removing childs", this);			for(var i=0; i < Puzzle.numChildren; i++) 			{     				stageShape = Puzzle.getChildAt(i)  as MovieClip;								if(stageShape is KpmShape)				{					//Util.debug("checking " + stageShape.getShortType(), this);					array.push(stageShape);   				}			}							for (var item in array)			{				Puzzle.removeChild(array[item]);			}		}				public function get NumTotalShapes()		{			return numShapes;		}			public function get Puzzle() : MovieClip { return Movie.tShape };			}}