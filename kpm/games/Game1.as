/***************************************/* Author : Carlos Lara/* variables :/* m: member, p: parameters, t : timeline/**************************************/package com.kpm.games {	import com.kpm.common.*;    import com.kpm.common.GameData;	import com.kpm.kpm.BubbleId;	import com.kpm.kpm.EBName;	import com.kpm.kpm.EBScoreType;	import com.kpm.kpm.EBStd;	import flash.display.DisplayObject;	import flash.display.MovieClip;import flash.display.Stage;import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.text.*;	import flash.ui.Keyboard;	import flash.utils.Timer;	import flash.utils.getTimer;	import mx.containers.Tile;	import mx.controls.Text;	public class Game1 extends Game	{		private var player 			: Game1Player;		private var targetList		: Array;		private var stepsToTarget 	: Array;		private var board			: Board;		private var arrowList		: MovieList;		public var playerMoveTimer	: Timer;		public var targetMoveTimer	: Timer;		public var lockPlayer		: Boolean;		private var pastChoices 	: Array;		private var taskCountdownList : MovieList;        public function Game1(isStandAlone : Boolean)        {            if(isStandAlone)                EventManager.addEvent(this, Event.ADDED_TO_STAGE, onInit);        }        public function onInit(e : Event)        {            initGame();            EventManager.removeEvent(this, Event.ADDED_TO_STAGE);        }		public function initGame(pBubbleId : BubbleId = null, pLanguage : ELanguage = null,								 pGameTheme : EGameCharacter = null)		{            Util.debug("Game1.initGame")            if(pBubbleId != null)                mData = new Game1Data(pBubbleId, pLanguage, this, pGameTheme);            else            {                //mData = new Game1Data(new BubbleId(EBName.IdentifyDiceDots, 4), ELanguage.SPA, this, EGameCharacter.Mouse);                mData = new Game1Data(new BubbleId(EBName.SpatialSense, 2), ELanguage.ENG, this, EGameCharacter.Frog);                //mData = new Game1Data(new BubbleId(EBName.SubsetFinger_5, 2), ELanguage.SPA, this, EGameCharacter.Mouse);                //mData = new Game1Data(new BubbleId(EBName.IdentifySize, 3), ELanguage.SPA, this, EGameCharacter.Frog);            }            initializeGameAssets();        }        function initializeGameAssets()		{			board = new Board(G1Data.board);			board.drawMcGrid(this, "BoardSquare");			player = new Game1Player(board, Board.ONE_TILE, G1Data.theme_PlayerFacing);			targetList = new Array(G1Data.gameGoal.numOptions);			arrowList = new MovieList(true, 3);			numbersList = new MovieList(true, 20);			taskCountdownList = new MovieList(true, 15);			pastChoices = new Array();			tBackground.gotoAndStop(G1Data.theme_PlayerName);			stage.addEventListener( Event.RENDER, startTask, false, 0, true );			stage.invalidate();		}		//Whenever the task is changed, update all game components		public function startTask(e:Event)		{			Util.debug("on task finished!", this);			stage.removeEventListener( Event.RENDER, startTask);			G1Data.resetTask();			board.emptyLogicBoard();			setPlayer();			setTargets();			setArrowList();			setAssetsScale();			setBoard();			setAssetsZOrdering();			initEvents(null);			resetInstructions();			setButtons(false);			setAssetsPosition();			unLockKeys(null);			G1Data.startTask(null);			G1Data.State = EState.INSTRUCTIONS;		}		public override function onRemove(e:Event)		{			removeEvents();		}		//When instructions finish playing, unlock keys, iniitalize music if necessary		public override function onInstructionsFinished (e:Event)		{			setButtons(true);		}		public override function createMusic() : KpmSound		{			return G1Data.createSound(G1Data.theme_PlayerName + GameData.GAME_PLAY, 1,						G1Data.theme_MusicVolume, true, false, true);		}		//unlock keys to allow user interaction		public override function unLockKeys(e : Event)		{			Util.debug(" UNLOCKING KEYS", this);			G1Data.keysLocked = false;			lockPlayer = false;			setButtons(true);			if(G1Data.State != EState.END_ANIMATION)				G1Data.State = EState.IDLE;		}		//Initialize the player's position		function setPlayer()		{			//Put the player in a corner of the stage			var tempx, tempy;			var tempPoint : Point2D;			if(player.Tile)			{				tempx = player.Tile.x;				tempy = player.Tile.y;			}			else			{				tempx = Util.getRandomExtreme(G1Data.lvl_SpaceToCorner, board.NumCols-1);				tempy = Util.getRandomExtreme(G1Data.lvl_SpaceToCorner, board.NumRows-1);			}			populateTaskCountdown();			if(G1Data.gameGoal.quality == EGoal.SPATIAL)			{				Util.debug("temp x " + tempx + " tempy " + tempy, this);				if(!(G1Data.lvl_TargetHorizontal && G1Data.lvl_TargetVertical))				{					if(G1Data.lvl_ClickTarget)					{						if(!G1Data.lvl_TargetHorizontal)							tempy = Util.getRandBtw(0 + 3, board.NumRows - 3);						else							tempx = Util.getRandBtw(0 + 3, board.NumCols - 3);					}					else					{                        //added aug2-2013 to change position of player in spatialsense1 and spatialsense2.                        tempy = Util.getRandBtw(0, board.NumRows-1);                        tempx = Util.getRandBtw(0, board.NumCols-1);						if(G1Data.firstLevel) {							if(Util.getRandBtw(0,1) == 0) 	G1Data.playerAboveTarget = 1;							else						    G1Data.playerAboveTarget = -1;						}						else {							G1Data.playerAboveTarget*= -1						}                        G1Data.firstLevel = false;                        Util.debug("Game1.setPlayer " + G1Data.playerAboveTarget + " " + G1Data.firstLevel);						if(G1Data.playerAboveTarget == 1) {							if(!G1Data.lvl_TargetHorizontal)								tempy = Util.getRandBtw(0, board.NumRows - G1Data.lvl_MinDistPlayerTarget - G1Data.gameGoal.numOptions);							else								tempx = Util.getRandBtw(0, board.NumCols - G1Data.lvl_MinDistPlayerTarget - G1Data.gameGoal.numOptions);						}						else {							if(!G1Data.lvl_TargetHorizontal)								tempy = Util.getRandBtw(G1Data.lvl_MinDistPlayerTarget + G1Data.gameGoal.numOptions - 1 , board.NumRows-1);							else								tempx = Util.getRandBtw(G1Data.lvl_MinDistPlayerTarget + G1Data.gameGoal.numOptions - 1, board.NumCols-1);						}					}				}			}			else if(G1Data.gameGoal.quality == EGoal.COUNT)			{				tempx = Util.getRandomExtreme(G1Data.lvl_SpaceToCorner, board.NumCols-1);				tempy = Util.getRandomExtreme(G1Data.lvl_SpaceToCorner, board.NumRows-1);			}			tempPoint = new Point2D(tempx, tempy);			//Move the player to that place			if(board.inBounds(tempPoint))			{				if(!player.Movie || G1Data.lvl_EatTarget)				{					addChild(player);					if(G1Data.lvl_SpatialSense || G1Data.firstLevel)						player.initialize(tempPoint, G1Data.theme_PlayerName, 14);					else						player.initialize(player.Tile, G1Data.theme_PlayerName, 14);					player.Movie.gotoAndPlay("rest");					player.Movie.visible = !G1Data.lvl_HidePlayer;				}			}			else			{				GameData.reportError("player not in bounds " + tempx + " " + tempy);			}			setPlayerPath();			Util.debug("player is at " + player.Tile, this);		}		function populateTaskCountdown()		{			Util.debug("G1.populateTaskCountDown");			Util.debug("Player name is " + G1Data.theme_PlayerName);			if(!taskCountdownList.Rows)			{				taskCountdownList.init();				addChild(taskCountdownList);				for(var i=0; i < G1Data.gameGoal.totalTasks - 1; i++)				{					var playerLives : GameComponent = new GameComponent();					playerLives.MovieName = G1Data.theme_PlayerName;					playerLives.Scale = G1Data.theme_PlayerScale*35;					taskCountdownList.add(playerLives);				}				taskCountdownList.y = this.height/6;				taskCountdownList.x = 30;				Util.debug("creating task countdownList" + taskCountdownList);			}			else			{				Util.debug("removing current live");				taskCountdownList.removeCurrent();			}		}		function setPlayerPath()		{			if(G1Data.lvl_ShowPath)				player.setPath();			else				player.clearPath();		}		//Initialize the targets, this depends on the bubble being played being played		function setTargets()		{			removeAllTargets();			if (G1Data.lvl_ClickTarget)			{				if(G1Data.gameGoal.quality == EGoal.SPATIAL)					populateIdentifySpatial();		 		else		 		{		 			setGoal();			 		if(Data.gameGoal.quality == EGoal.COLOR || Data.gameGoal.quality == EGoal.SIZE)			 			populateColorSizes();			 		else if(G1Data.gameGoal.quality == EGoal.NUMBER)			 			populateNumbers();			 		else if (G1Data.lvl_SubsetValue > 0)			 		{			 			populateSubset();			 		}			 		else if (G1Data.gameGoal.quality == EGoal.COUNT)			 			populateCount();			 	}			}			else if(G1Data.lvl_SpatialSense)			{				populateSpatialSense();			}		}		//Initialize target somewhere not close to the Game1Player		function populateSpatialSense()		{			var tempTargetTile : Point2D;			var tempTarget : Game1Target;			//Put the target in the opposite quadrant as the player			var i=0;			do			{				i++;				tempTargetTile = getPossibleTargetTile();//				Util.debug("target tile " + tempTargetTile, this);//				Util.debug("player tile " + Player.Tile, this);//				Util.debug("distance " + Util.manhDistance(Player.Tile, tempTargetTile), this)//				Util.debug("min distance " +  G1Data.lvl_MinDistPlayerTarget, this);			}			//while(false);			while(i < 11 &&				 (Util.manhDistance(player.Tile, tempTargetTile) <  G1Data.lvl_MinDistPlayerTarget ||			       Util.manhDistance(player.Tile, tempTargetTile) >  G1Data.lvl_MaxDistPlayerTarget));			tempTarget = new Game1Target(board, Board.ONE_TILE, G1Data.theme_EatedName);			tempTarget.Tile = tempTargetTile.clone();			targetList[0] = tempTarget;			G1Data.CurrentGoal = targetList[0].Tile;			addChild(targetList[0]);			board.addObject(targetList[0], Board.TILE_TARGET);		}		//Return a possible target, far from the player		function getPossibleTargetTile() : Point2D		{			var tempPoint   : Point2D = new Point2D(0,0);			var randomPoint : Point2D = new Point2D(0,0);			var distancePlayerTarget : uint = Util.getRandBtw(G1Data.lvl_MinDistPlayerTarget, G1Data.lvl_MaxDistPlayerTarget);			Util.debug("distance to target " + distancePlayerTarget + " " + G1Data.lvl_MinDistPlayerTarget + " " + G1Data.lvl_MaxDistPlayerTarget);			//			if((G1Data.lvl_TargetVertical && G1Data.lvl_TargetHorizontal)) {				if(G1Data.lvl_MaxDistPlayerTarget > board.NumCols + board.NumRows)				{					Util.debug("random point in other half");					randomPoint = Util.getRandomPointInOtherHalf(player.Tile, board);				}				else				{					do					{						Util.debug("distance player target " + distancePlayerTarget);						randomPoint = Util.getRandomPointFarEnough(player.Tile, board, distancePlayerTarget, 30, G1Data.lvl_MaxPerAxe);						if(!randomPoint)							distancePlayerTarget--;					}					while(!randomPoint)				}				//randomPoint.x = Util.getRandomNumberInOtherHalf(player.Tile.x, board.NumCols);				//randomPoint.y = Util.getRandomNumberInOtherHalf(player.Tile.y, board.NumRows);			}			else			{				if(!G1Data.lvl_TargetHorizontal) 	randomPoint.x = player.Tile.x;				if(!G1Data.lvl_TargetVertical) 		randomPoint.y = player.Tile.y;				if(G1Data.playerAboveTarget == 1)				{					if(!G1Data.lvl_TargetHorizontal)						randomPoint.y = Util.getRandBtw(player.Tile.y + G1Data.lvl_MinDistPlayerTarget, board.NumRows-1);					else						randomPoint.x = Util.getRandBtw(player.Tile.x + G1Data.lvl_MinDistPlayerTarget, board.NumCols-1);				}				else				{					if(!G1Data.lvl_TargetHorizontal)						randomPoint.y = Util.getRandBtw(0, player.Tile.y - G1Data.lvl_MinDistPlayerTarget);					else						randomPoint.x = Util.getRandBtw(0, player.Tile.x - G1Data.lvl_MinDistPlayerTarget);				}			}			tempPoint.x = randomPoint.x;			tempPoint.y = randomPoint.y;//			Util.debug("target tile !!!!! " + tempPoint, this);			return tempPoint;		}		//Populate more than one target for the bubble Spatial Sense level 6		function populateIdentifySpatial()		{			var tempTarget : Game1Target;			var referenceTile : Point2D ;			Util.debug("populate identify spatial");			for(var i=0; i < G1Data.gameGoal.numOptions; i++)			{				tempTarget = new Game1Target(board, Board.ONE_TILE, G1Data.theme_EatedName);				var j =0;				do				{					j++;					tempTarget.Tile = new Point2D(0,0);					if(G1Data.lvl_SpatialDifference == 0)					{						tempTarget.Tile = Util.addNoiseTiles(player.Tile, Board.ONE_TILE);						var noise : Point2D;						if(!G1Data.lvl_TargetHorizontal)							noise = new Point2D(0,3);						else							noise = new Point2D(3,0);						tempTarget.Tile = Util.addNoiseTiles(player.Tile, noise);					}					else					{						if(i == 0)	referenceTile = getPossibleTargetTile();						tempTarget.Tile.y = Util.getRandBtw(referenceTile.y - 1, referenceTile.y + 1);						tempTarget.Tile.x = Util.getRandBtw(referenceTile.x - 1, referenceTile.x + 1);					}					if(j > 40)					{						throw new Error("identify Spatial failed");					}					Util.debug(" i " + i + " generating tempTarget " + tempTarget.Tile, this)					if(!board.isEmpty(tempTarget))					{						Util.debug("tile is not empty", this);						//board.printLogicBoard();					}					if(Util.manhDistance(player.Tile, tempTarget.Tile) <  G1Data.lvl_MinDistPlayerTarget)						Util.debug("min distance" + G1Data.lvl_MinDistPlayerTarget, this);					if(Util.manhDistance(player.Tile, tempTarget.Tile) >  G1Data.lvl_MaxDistPlayerTarget)						Util.debug("max distance" + G1Data.lvl_MinDistPlayerTarget, this);				}				while(!board.isEmpty(tempTarget)				|| Util.manhDistance(player.Tile, tempTarget.Tile) <  G1Data.lvl_MinDistPlayerTarget				|| Util.manhDistance(player.Tile, tempTarget.Tile) >  G1Data.lvl_MaxDistPlayerTarget);				targetList[i] = tempTarget;				targetList[i].Tile = tempTarget.Tile;				board.addObject(targetList[i], Board.TILE_DISTRACTOR);                var emptyBox : MovieClip = Util.addButtonBox(targetList[i], new EmptyBox(), board.TileSize, board.TileSize)                targetList[i].addChild(emptyBox);                targetList[i].setChildIndex(emptyBox, 0);                targetList[i].buttonMode = true;			}			for(var k=0; k < G1Data.gameGoal.numOptions; k++)			{				addChild(targetList[k]);				board.addObject(targetList[k], Board.TILE_DISTRACTOR);				targetList[k].addEventListener(MouseEvent.CLICK, onIdentifySpatialClicked,false,0,true);				if(k == 0)				{					stepsToTarget = Util.makePathFrom(player.Tile, targetList[0].Tile, 1);					board.addObject(targetList[0], Board.TILE_TARGET);					G1Data.CurrentGoal = targetList[0].Tile;				}			}		}		function setGoal()		{//			Util.debug("setting goal", this);//			Util.printArray(G1Data.lvl_DistractorList);//			Util.debug(G1Data.gameGoal.pastGoal,this);			var goal : Object;			if(G1Data.lvl_DistractorList.length == 2 && G1Data.gameGoal.pastGoal != G1Data.gameGoal.pastpastGoal)			{				Util.debug("Distractrors list is less than 2");				goal = Util.getRandomFrom(G1Data.lvl_DistractorList)			}			else			{				Util.debug("past goal is " + G1Data.gameGoal.pastGoal);				goal = Util.getRandomElementNotIn(G1Data.lvl_DistractorList, [G1Data.gameGoal.pastGoal]);			}			G1Data.gameGoal.pastpastGoal = G1Data.gameGoal.pastGoal;			G1Data.CurrentGoal = goal; 			G1Data.gameGoal.pastGoal = goal; 			if(!G1Data.gameGoal.pastGoals)	 			G1Data.gameGoal.pastGoals = new Array();	 		if(!G1Data.gameGoal.pastQualities)	 			G1Data.gameGoal.pastQualities = new Array();	 		G1Data.gameGoal.pastGoals.push(goal);		}	 	//Populate movies for bubble IdentifyColor	 	function populateColorSizes()	 	{	 		//Util.printArray(pMovies);	 		var allChoices : Array = new Array();	 		var currentMovieName : String;	 		var quality : EGoal;	 		currentMovieName = G1Data.lvl_TargetMovieNames[0] + "Gray";	 		currentColor = Util.getRandomFrom(GameData.ecolors);	 		if(G1Data.gameGoal.quality == EGoal.COUNT)	 		{	 			var maxTarget = Math.min(G1Data.lvl_SubsetValue, G1Data.CurrentGoal.Text + 6);	 			G1Data.gameGoal.numOptions = Util.getRandBtw(uint(maxTarget*0.8), maxTarget)	 			targetList = new Array(G1Data.gameGoal.numOptions);	 			//G1Data.gameGoal.numTargets = G1Data.lvl_SubsetValue;	 			Util.debug("subquality " + G1Data.gameGoal.subquality);	 			quality = G1Data.gameGoal.subquality;	 			if(G1Data.lvl_SubjectsList.length > 2)	 			{	 				allChoices = Util.chooseRandomElements(G1Data.lvl_SubjectsList, Util.getRandBtw(2,3));	 			}	 			else	 				allChoices = G1Data.lvl_SubjectsList;	 		}	 		else	 		{	 			G1Data.gameGoal.numCorrectOptions = Util.getRandBtw(G1Data.lvl_MinCorrectTargets,G1Data.lvl_MaxCorrectTargets);	 			quality = G1Data.gameGoal.quality;	 			allChoices = G1Data.lvl_DistractorList;	 		}	 		if(G1Data.gameGoal.quality == EGoal.COUNT)	 		{	 			if(Util.getRandBtw(0,1) == 0 && quality == EGoal.SIZE)	 				G1Data.gameGoal.currentQuality = Util.getRandomFrom(allChoices);	 			else	 				G1Data.gameGoal.currentQuality = Util.getRandomElementNotIn(allChoices, G1Data.gameGoal.pastQualities);	 		}	 		else	 			G1Data.gameGoal.currentQuality = G1Data.gameGoal.currentGoal;	 		Util.debug("current quality " + G1Data.gameGoal.currentQuality);	 		Util.debug("num targets " + G1Data.gameGoal.numOptions);			Util.debug("num correct targets " + G1Data.gameGoal.numCorrectOptions);	 		for(var i=0; i< G1Data.gameGoal.numOptions; i++)			{				targetList[i] = addTarget(false);				targetList[i].MovieName = currentMovieName;				if(i == 0)				{					G1Data.gameGoal.pastQualities.push(G1Data.gameGoal.currentQuality);					if(G1Data.lvl_SubsetValue == 0)					{						G1Data.CurrentGoal = G1Data.gameGoal.currentQuality;						G1Data.gameGoal.pastGoal = G1Data.gameGoal.currentQuality;					}				}				Util.debug("past qualities");				Util.printArray(G1Data.gameGoal.pastQualities)				Util.debug("allChoices");				Util.printArray(allChoices);				Util.debug("past goal");				Util.debug(G1Data.gameGoal.pastGoal);				if(i < G1Data.gameGoal.numCorrectOptions)				{					Util.debug("populating correct target" + quality);					if(G1Data.gameGoal.quality != EGoal.COUNT)						populatePrice(i);					if(quality == EGoal.COLOR)					{						Util.debug("setting color to " + G1Data.gameGoal.currentQuality);						targetList[i].Color = G1Data.gameGoal.currentQuality as EColor;					}					else if (quality == EGoal.SIZE)					{						Util.debug("setting size to " + G1Data.gameGoal.currentQuality);						targetList[i].Size = G1Data.gameGoal.currentQuality as ESize;					}					board.addObject(targetList[i], Board.TILE_TARGET);				}				else				{					Util.debug("populating incorrect target" + quality);					if(quality == EGoal.COLOR)					{						targetList[i].Color = Util.getRandomElementNotIn(allChoices, [G1Data.gameGoal.currentQuality]) as EColor;						Util.debug("setting color to " + targetList[i].Color);						targetList[i].feedbackSound = targetList[i].Color.Text;						G1Data.gameGoal.pastQualities.push(targetList[i].Color.Text);					}					else if(quality == EGoal.SIZE)					{						targetList[i].Size = Util.getRandomElementNotIn(allChoices, [G1Data.gameGoal.currentQuality]) as ESize;						Util.debug("setting color to " + targetList[i].Size);						G1Data.gameGoal.pastQualities.push(targetList[i].Size);						targetList[i].feedbackSound = targetList[i].Size.Text;					}					board.addObject(targetList[i], Board.TILE_DISTRACTOR);				}				if(quality != EGoal.COLOR)				{					if(!G1Data.lvl_DifferentColors)						targetList[i].Color = currentColor;					else						targetList[i].Color = Util.getRandomFrom(GameData.ecolors);				}                if(quality != EGoal.COUNT)                {                    var emptyBox : MovieClip = Util.addButtonBox(targetList[i], new EmptyBox(), board.TileSize, board.TileSize)                    targetList[i].addChild(emptyBox);                    targetList[i].setChildIndex(emptyBox, 0);                    targetList[i].buttonMode = true;                }                Util.debug("target color " + targetList[i].Color);				if(G1Data.gameGoal.pastQualities.length == 2)				{					G1Data.gameGoal.pastQualities = new Array();					G1Data.gameGoal.pastQualities.push(G1Data.gameGoal.currentQuality);				}			}	 	}			//Populate targets for bubble IdentifyFinger, Numeral, 5Frame	 	function populateNumbers()	 	{ 			var currentNumber : ENumber; 			var verticalLayout : Boolean = true; 			var center : Number; 			Util.debug("Game1.populateNnumbers", this); 			Util.debug("max value " + G1Data.lvl_MaxTargetValue + " " + G1Data.CurrentGoal); 			G1Data.gameGoal.numCorrectOptions = Util.getRandBtw(G1Data.lvl_MinCorrectTargets, G1Data.lvl_MaxCorrectTargets);			if(G1Data.lvl_MaxTargetValue > 10)				center = Math.min(G1Data.lvl_MaxTargetValue-2, Util.getRandBtw(G1Data.CurrentGoal.Text -2, G1Data.CurrentGoal.Text +2)); 			if(G1Data.gameGoal.achievedGoals.length == G1Data.lvl_DistractorList.length) 			{ 				G1Data.gameGoal.achievedGoals = new Array(); 			}	 		for(var i=0; i< G1Data.gameGoal.numOptions; i++)			{				targetList[i] = addTarget();                if(i < G1Data.gameGoal.numCorrectOptions)				{					currentNumber = G1Data.CurrentGoal;					Util.debug("currentNumber " + currentNumber, this);					if(i==0)						pastChoices.push(currentNumber);				}				else				{					if(G1Data.lvl_MaxTargetValue > 10)					{						Util.debug("center is " + center);						do						{							currentNumber = ENumber.getEnum(Util.getRandBtw(center - 2, center + 2));						}						while(currentNumber == G1Data.CurrentGoal);					}					else						currentNumber = Util.getRandomElementNotIn(G1Data.lvl_DistractorList, pastChoices) as ENumber;					if(G1Data.gameGoal.numOptions <= 5)						pastChoices.push(currentNumber);				}				var form : ENumberForm				if(G1Data.lvl_TargetMovieNames.length != 1)				{					form = Util.getRandomFrom(G1Data.lvl_TargetMovieNames) as ENumberForm;				}				else				{					form = G1Data.lvl_TargetMovieNames[0];				}				if(currentNumber.Text > 10)				{					if(form == ENumberForm.Numeral)					{						targetList[i].MovieName = form.Text + int(currentNumber.Text/10);						if(currentNumber.Text >= 20 || currentNumber.Text == 11)						{							targetList[i].addMovie(String(form.Text + currentNumber.Text%10), true, 0);							targetList[i].Movie.x -= targetList[i].Movie.width/3;						}						else						{							targetList[i].addMovie(String(form.Text + currentNumber.Text%10), true, 10);							targetList[i].Movie.x -= targetList[i].Movie.width/2;						}					}					else if(form == ENumberForm.FiveFrame)					{						targetList[i].MovieName = form.Text + "10";						//if(currentNumber.Text >= 20)						//	targetList[i].addMovie(form.Text + "10", false, targetList[i].Movie.height/5);						if(currentNumber.Text > 10)						{							targetList[i].Movie.y -= targetList[i].Movie.height;							if(currentNumber.Text <= 15)								targetList[i].addMovie(String("tenframe" + form.Text + (currentNumber.Text-10)), false, targetList[i].Movie.height/5);							if(currentNumber.Text > 15)								targetList[i].addMovie(String(form.Text + (currentNumber.Text-10)), false, targetList[i].Movie.height/5);						}					}				}				else				{					targetList[i].MovieName = form.Text + currentNumber.Text;				}				if(G1Data.lvl_MaxTargetValue > 10)				{					targetList[i].scaleX *= 0.74;					targetList[i].scaleY *= 0.74;				}				if(i < G1Data.gameGoal.numCorrectOptions)				{					populatePrice(i);				}				else				{					targetList[i].feedbackSound = currentNumber.Text;				}				if(pastChoices.length == G1Data.lvl_DistractorList.length)				{					pastChoices = new Array();					pastChoices.push(G1Data.CurrentGoal);				}                var emptyBox : MovieClip = Util.addButtonBox(targetList[i], new EmptyBox(), board.TileSize, board.TileSize)                targetList[i].addChild(emptyBox);                targetList[i].setChildIndex(emptyBox, 0);                targetList[i].buttonMode = true;            }	 	}		//Populate for Count levels		function populateCount()		{ 			var addToLogicBoard : Boolean = true; 			var startPoint : Point2D; 			var tempPlayerTile : Point2D; 			var i : int = 0;			var currentMovieName : String;			var currentColor : EColor;	 		currentMovieName = G1Data.lvl_TargetMovieNames[0] + "Gray";	 		currentColor = Util.getRandomFrom(GameData.ecolors) as EColor; 			Util.debug("Populating count", this); 			Util.printArray(G1Data.lvl_DistractorList); 			setNumbersList(); 			if(!(G1Data.lvl_TargetHorizontal || G1Data.lvl_TargetVertical)) 				addToLogicBoard = true; 			else 				addToLogicBoard = false 			targetList = new Array(G1Data.CurrentGoal.Text); 			for(var j=0; j< G1Data.CurrentGoal.Text; j++)			{				targetList[j] = addTarget(addToLogicBoard);				targetList[j].MovieName = currentMovieName;				if(G1Data.lvl_DifferentColors)					targetList[j].Color = Util.getRandomFrom(GameData.ecolors) as EColor;				else					targetList[j].Color = currentColor;				if(j == 0)					pastChoices.push(G1Data.CurrentGoal);			}			placeTargetsCountInLine();			choosePlayerFarEnough();			if(pastChoices.length == G1Data.lvl_DistractorList.length)			{				pastChoices = new Array();				pastChoices.push(G1Data.CurrentGoal);			}			Util.debug("past goal " + G1Data.gameGoal.pastGoal, this);		}		function choosePlayerFarEnough()		{			var k = 0;			do			{				var i : Number = Util.getRandBtw(0, G1Data.gameGoal.numCorrectOptions-1);				G1Data.gameGoal.correctTargetIndex = i;				var tempPlayerTile : Point2D = Util.getRandomPointFarEnough(targetList[i].Tile, board, G1Data.CurrentGoal.Text, 15, 10);				k++;				if(k > 100)					GameData.reportError ("choose player far enough failed");			}			while(!tempPlayerTile);			player.Tile = tempPlayerTile;		}		function placeTargetsCountInLine()		{			var tileList : Array;			if(G1Data.lvl_TargetHorizontal && !G1Data.lvl_TargetVertical)			{				if(G1Data.CurrentGoal.Text == 10)					tempPoint = new Point2D(0,0);				else					tempPoint = board.getRandomPoint(new Point2D(5, (G1Data.CurrentGoal.Text / 5) + 1));				tileList = board.getTilesInLine(tempPoint, G1Data.CurrentGoal.Text, 5, 0);			}			else if(!G1Data.lvl_TargetHorizontal && G1Data.lvl_TargetVertical)			{				if(G1Data.CurrentGoal.Text == 10)					tempPoint = new Point2D(0,0);				else					tempPoint = board.getRandomPoint(new Point2D((G1Data.CurrentGoal.Text / 5) + 1, 5));				tileList = board.getTilesInLine(tempPoint, G1Data.CurrentGoal.Text, 0, 5);				Util.debug("pex " + tempPoint);			}			if(G1Data.lvl_TargetHorizontal || G1Data.lvl_TargetVertical)			{				for(var i=0; i < targetList.length; i++)				{					targetList[i].Tile = tileList[i];					board.addObject(targetList[i], Board.TILE_DISTRACTOR);				}			}		}		function setNumbersList()		{			var numberArray : Array;			var numbersMovieHeight = board.NumRows * board.TileSize;			numbersList.init();			G1Data.gameGoal.numCorrectOptions = G1Data.CurrentGoal.Text;			addChild(numbersList);			numberArray = Util.generateNumberArray(G1Data.CurrentGoal.Text, G1Data.lvl_MaxTargetValue);			if(numberArray.length == 0)				GameData.reportError("nothing in numberArray");			Util.debug("number array", this);			Util.printArray(numberArray);			numbersList.FixedHeight = numbersMovieHeight/numberArray.length;			for(var j =0; j < numberArray.length; j++)			{				numbersList.add(new Counter(Util.getRandomFrom(G1Data.lvl_OptionsMovieNames), numberArray[j].Text, stage));				numbersList.MovieArray[j].addEventListener(MouseEvent.CLICK, onNumberClick, false, 0 , true);				numbersList.MovieArray[j].feedbackSound = numberArray[j].Text;				numbersList.MovieArray[j].Scale = 1.3;				CursorManager.addOverEvents(numbersList.MovieArray[j]);				Util.debug("numbers list feedback " + numberArray[j].Text);                var emptyBox : MovieClip = Util.addButtonBox(numbersList.MovieArray[j], new EmptyBox());                numbersList.MovieArray[j].addChild(emptyBox);                numbersList.MovieArray[j].setChildIndex(emptyBox, 0);                numbersList.MovieArray[j].buttonMode = true;			}		}		function populateSubset()		{			Util.debug("Populating subset", this); 			Util.printArray(G1Data.lvl_DistractorList);			setNumbersList();			populateColorSizes();			choosePlayerFarEnough();		}	 	function moveTargetsCount()	 	{	 		var target : TiledGameComponent;	 		var position : Point2D = player.Tile.clone();	 		var steps : Array = new Array();	 		var doMove : Array = new Array();	 		if(G1Data.CurrentGoal.Text == 1)	 		{	 			playerMoveToTarget();	 			return;	 		}	 		for(var i =0; i < targetList.length; i++)	 		{	 			if(i < G1Data.CurrentGoal.Text)	 			{	 				var direction : Point2D = arrowList.NextMc.direction;	 				position.add(direction);	 				steps.push(position.clone());	 				Util.debug("pushing true to " + targetList[i].Tile);	 				doMove.push(-1);	 			}	 			else	 			{	 				Util.removeChild(targetList[i]);	 			}	 		}	 		for(var j =0; j < G1Data.CurrentGoal.Text; j++)	 			for(var k =0; k < G1Data.CurrentGoal.Text; k++)	 				if(targetList[j].Tile.equals(steps[k]))	 				{	 					Util.debug("target comparing " + j + " " +  targetList[j].Tile + " " + k + " " + steps[k]);	 					doMove[j] = k;	 				}	 		var l = 0;	 		Util.printArray(steps);	 		for(var i =0; i < G1Data.CurrentGoal.Text; i++)	 		{	 			var valid = true;	 			if (doMove[j] == i)	 			{	 				Util.debug("pex " +  j + " " + l);	 				valid = false	 			}	 			if(i != G1Data.gameGoal.correctTargetIndex && valid)	 			{	 				Util.debug("moving target " + i + " " + targetList[i].Tile + " to " + l + " " +  steps[l]);	 				targetList[i].moveToTile(steps[l], GameData.MOVE_TO_TARGET_TIME);	 			}	 			if(i != G1Data.gameGoal.correctTargetIndex)	 				l++;	 		}	 		targetMoveTimer = new Timer(GameData.MOVE_TO_TARGET_TIME * 1000, 1);	 		targetMoveTimer.start();	 		targetMoveTimer.addEventListener(TimerEvent.TIMER_COMPLETE, playerMoveToTarget, false, 0 , true);	 	}	 	//Adds the goal as a correct answer	 	function populatePrice( i : int)	 	{	 		var priceMovie : MovieClip = new TiledGameComponent(board, Board.ONE_TILE);			board.addObject(targetList[i], Board.TILE_TARGET);	 		if(G1Data.gameGoal.answerEndsTask())	 		{				priceMovie.MovieName = G1Data.theme_EatedName;				priceMovie.scaleX = priceMovie.scaleY = G1Data.board.tileSize*G1Data.theme_TargetScale/targetList[0].scaleX;				targetList[i].addChild(priceMovie);				if(!(G1Data.theme_EatedName == "Fly" &&					 G1Data.gameGoal.currentGoal is EColor))				{					targetList[i].setChildIndex(priceMovie, 0);				}				if (player.Tile <= targetList[i].Tile &&					G1Data.theme_EatedName == "Cheese")						priceMovie.scaleX *= -1;			}	 	}		//Adds a distractor or target	 	function addTarget(addToLogicBoard : Boolean = true) : TiledGameComponent	 	{	 		var target : TiledGameComponent = new TiledGameComponent(board, Board.ONE_TILE); 			Util.debug("player tile", this); 			Util.debug(player.Tile, this);			do				 target.Tile = board.getRandomPoint(target.tileSize);			while(!board.isEmpty(target, [player.Tile]));			addChild(target);			if(addToLogicBoard)				board.addObject(target, Board.TILE_DISTRACTOR);			if(G1Data.lvl_ClickOnGrid)				target.addEventListener(MouseEvent.CLICK, onIdentifyClick, false, 0 , true);			if(GameData.driver)				CursorManager.addOverEvents(target);			return target;	 	}		function onNumberClick(e:Event)		{			if(clicksNotAllowed())				return;			Util.debug(e.currentTarget, this);			var stepsArray : Array			var currPos : Point2D;			var valid : Boolean = true;            G1Data.soundLibrary.forceStop();            clickedTarget = e.currentTarget;			Util.debug("Gam1.onNumberClick" + clickedTarget.number, this);			Util.debug("feedback " + clickedTarget.feedbackSound)			G1Data.gameGoal.currentMove = clickedTarget.feedbackSound;			if(clickedTarget.number == G1Data.CurrentGoal.Text)			{				var l = 0;				do				{					valid = true;					stepsToTarget = Util.makePathFrom(player.Tile, targetList[G1Data.gameGoal.correctTargetIndex].Tile, 1);					currPos = player.Tile.clone();					for(var i=0; i < stepsToTarget.length; i++)					{						currPos.add(stepsToTarget[i]);						if(board.logicBoard[currPos.x][currPos.y] != Board.TILE_EMPTY						  && board.logicBoard[currPos.x][currPos.y] != Board.TILE_TARGET)						  	valid = false;					}					l++;					board.printLogicBoard();				}				while(!valid && l < 10);                Util.debug("good move " + stepsToTarget.length);                if(stepsToTarget.length > 1)				    G1Data.soundLibrary.playLibSound(ESoundType.Feedback, EState.GOOD_MOVE, G1Data.Language);                tFeedbackText.text = "Good Job!"				player.Movie.visible = true;				setArrowList();				G1Data.CurrentTaskSuccess = GameData.TASK_SUCCESS;				moveTargetsCount();				for(var j =0; j < numbersList.MovieArray.length; j++)				{					if(numbersList.MovieArray[j].number != G1Data.CurrentGoal.Text)						Util.removeChild(numbersList.MovieArray[j]);				}			}			else			{				Util.removeChild(clickedTarget);				G1Data.State = EState.BAD_MOVE;			}		}	 	function onIdentifyClick(e : Event)		{            Util.debug("clicking " + G1Data.keysLocked, this);			if(G1Data.keysLocked)				return;			else				G1Data.State = EState.IDLE;            clickedTarget = e.currentTarget as TiledGameComponent;            //if(clickedTarget.feedbackSound == G1Data.gameGoal.currentMove)              //  return;            G1Data.soundLibrary.forceStop();			G1Data.gameGoal.currentMove = clickedTarget.feedbackSound;			Util.debug("current Move to " + clickedTarget.feedbackSound + " " + clickedTarget, this);			for(var i=0; i< G1Data.gameGoal.numCorrectOptions; i++)			{				Util.debug("checking " + clickedTarget + " " + targetList[i] + " index " + i, this);				Util.debug("right targets " + G1Data.gameGoal.numCorrectOptions, this);				if(clickedTarget == targetList[i])				{					G1Data.keysLocked = true;					stepsToTarget = Util.makePathFrom(player.Tile, targetList[i].Tile, 1);                    Util.debug("good move " + stepsToTarget.length);                    if(stepsToTarget.length > 1)					    G1Data.soundLibrary.playLibSound(ESoundType.Feedback, EState.GOOD_MOVE, G1Data.Language);					tFeedbackText.text = "Good Job!"					setArrowList();					setPlayerPath();					//G1Data.gameGoal.addMoves(true);					G1Data.CurrentTaskSuccess = GameData.TASK_SUCCESS;					playerMoveToTarget();					for(var i=G1Data.gameGoal.numCorrectOptions; i< targetList.length ; i++)						Util.removeChild(targetList[i]);					return;				}			}			Util.removeChild(clickedTarget);			G1Data.State = EState.BAD_MOVE;		}		function onIdentifySpatialClicked(e:Event)		{			Util.debug("clicking " + G1Data.Bubble, this);			if(playerMoveTimer != null)				return;            G1Data.soundLibrary.forceStop();            var target : Game1Target = (e.currentTarget) as Game1Target;			Util.debug("target tile log " + target.Tile.Text, this);			G1Data.gameGoal.currentMove = target.Tile;			if(target == targetList[0])			{				playerMoveToTarget();				G1Data.CurrentTaskSuccess = GameData.TASK_SUCCESS;                G1Data.soundLibrary.playLibSound(ESoundType.Feedback, EState.GOOD_MOVE, G1Data.Language);                //G1Data.gameGoal.addMoves(true);			}			else			{				removeChild(target);				G1Data.State = EState.BAD_MOVE;			}		}		//Enable/Disable buttons		function setButtons(pEnable : Boolean)		{			Util.debug("SetButtons " + G1Data.gameGoal.quality)			//if(!pEnable && !G1Data.firstLevel)			//	pEnable = true			tArrowUpButton.visible 	  	= tArrowDownButton.visible   = false;			tArrowRightButton.visible 	= tArrowLeftButton.visible	= false;			tGoButton.visible 			= false;			if(G1Data.gameGoal.quality == EGoal.COUNT)			{				numbersList.visible = true;			}			Util.debug("no arrows visible " + G1Data.lvl_noArrowsVisible);			if(G1Data.lvl_noArrowsVisible == true)				return;			tArrowUpButton.visible 	  	= tArrowDownButton.visible   = G1Data.lvl_TargetVertical;			tArrowUpButton.enabled 	  	= pEnable;			tArrowDownButton.enabled 	= pEnable;			tArrowRightButton.visible 	= tArrowLeftButton.visible	= G1Data.lvl_TargetHorizontal;			tArrowRightButton.enabled 	= pEnable;			tArrowLeftButton.enabled 	= pEnable;			tGoButton.visible 			= G1Data.lvl_HoldPosition;			tGoButton.enabled 	  		= pEnable;			if(pEnable)			{				if(GameData.driver) CursorManager.addOverEvents(tGoButton);				if(GameData.driver) CursorManager.addOverEvents(tArrowUpButton);				if(GameData.driver) CursorManager.addOverEvents(tArrowDownButton);				if(GameData.driver) CursorManager.addOverEvents(tArrowRightButton);				if(GameData.driver) CursorManager.addOverEvents(tArrowLeftButton);			}			else			{				if(GameData.driver) CursorManager.removeOverEvents(tArrowUpButton);				if(GameData.driver) CursorManager.removeOverEvents(tArrowDownButton);				if(GameData.driver) CursorManager.removeOverEvents(tArrowRightButton);				if(GameData.driver) CursorManager.removeOverEvents(tArrowLeftButton);				if(GameData.driver) CursorManager.removeOverEvents(tGoButton);			}		}		//set the board and obstacles		function setBoard()		{			for each (var npc : MovieClip in board.npcArray)				removeChild(npc);			board.npcArray = new Array();			if(G1Data.lvl_SpatialSense)			{				if(G1Data.lvl_Obstacles == true)				{					setObstacles();				}				board.initLogicBoard(targetList[0].Tile)				G1Data.gameGoal.lengthOptimalPath = board.logicBoard[player.initialTile.x][player.initialTile.y];			}		}		//initialize the arrow list that will display the path		function setArrowList()		{			if(G1Data.lvl_HoldPosition || G1Data.gameGoal.numOptions > 1)			{				arrowList.init();			}			if(G1Data.Bubble.Name.Standard == EBStd.SpatialSense )			{				addChild(arrowList);				arrowList.visible = true;			}			if(G1Data.gameGoal.numOptions > 1 && stepsToTarget)			{				for (var i=0; i< stepsToTarget.length; i++)					arrowList.add(new Game1SmallArrow(stepsToTarget[i]));			}		}		function setObstacles()		{			var smartObsPos 	: Point2D;			var fraction 		: Number;			var tempObstacle 	: Obstacle;			for(var i : uint =0; i < G1Data.lvl_NumObstacles; i++)			{				fraction = (i+1 as Number)/(G1Data.lvl_NumObstacles+1)	;				var obstacleIndex = Util.getRandBtw(0,G1Data.theme_ObstacleNames.length-1);				tempObstacle = new Obstacle(board, G1Data.theme_ObstacleSizes[obstacleIndex],													G1Data.theme_ObstacleNames[obstacleIndex].Text);				var j =0;				do				{					smartObsPos = Util.interpolatePoint2D(player.Tile, targetList[0].Tile, fraction);					Util.debug("position" + smartObsPos, this);					if(G1Data.lvl_ObstacleError > 0)						tempObstacle.Tile = Util.addNoise(smartObsPos,board,G1Data.lvl_ObstacleError);					else						tempObstacle.Tile = board.getRandomPoint(tempObstacle.tileSize);					tempObstacle.Tile = board.bringIn(tempObstacle);					Util.debug("temp obstacle" + tempObstacle.Tile, this);					Util.debug("player " + player.Tile, this);					Util.debug("target " + targetList[0].Tile, this);					if(j > 200)						GameData.reportError("failed at placing obstacle");					j++;				}				while (!board.isEmpty(tempObstacle, [player.Tile]));				board.addObject(tempObstacle, Board.TILE_OBSTACLE);				board.npcArray.push(tempObstacle);				addChild(tempObstacle);			}		}		public function setAssetsScale()		{			player.Scale = G1Data.board.tileSize*G1Data.theme_PlayerScale;			player.Movie.x = G1Data.theme_PlayerCenter.x;			player.Movie.y = G1Data.theme_PlayerCenter.y;			for (var i=0; i < targetList.length ; i++)			{				targetList[i].Scale = G1Data.board.tileSize*G1Data.theme_TargetScale;				if(G1Data.lvl_DifferentScales)				{					if(G1Data.gameGoal.quality == EGoal.SIZE || G1Data.gameGoal.subquality == EGoal.SIZE)					{						Util.debug("setting scale " + GameData.sizesNumber[targetList[i].Size.Text], this);						targetList[i].Scale *= GameData.sizesNumber[targetList[i].Size.Text];					}					else					{						var scale : Number  = Util.getRandBtw(5,10);						targetList[i].Scale*= scale/10;						//Util.debug("setting scale " + (scale/10));					}				}				//if(G1Data.lvl_MaxTargetValue > 5)				//	targetList[i].Scale *= 0.8;			}		}		public function setAssetsPosition()		{			Util.debug("tArrow DOwn " + tArrowUpButton);			Util.debug(tFeedbackText);			if(!tArrowUpButton)				throw new Error("q pex no tArrowButton!");			var boardEndsX : Number = board.PixelWidth + G1Data.board.Offset.x;			var arrowButtonX : Number = boardEndsX + tArrowUpButton.width *1.4 ;			tFeedbackText.x = boardEndsX/2 - tFeedbackText.width/3;			tArrowUpButton.x = tArrowDownButton.x = tArrowLeftButton.x = tArrowRightButton.x = arrowButtonX;			tGoButton.x = arrowButtonX;			if(G1Data.lvl_ClickTarget && G1Data.gameGoal.quality != EGoal.SPATIAL)				arrowList.visible = false;			else			{				arrowList.x = tArrowUpButton.x + tArrowUpButton.width*2;				arrowList.y = 40;			}			if(G1Data.gameGoal.quality == EGoal.COUNT)			{				numbersList.x = boardEndsX + numbersList.width;				numbersList.y = 90;			}		}		public function setAssetsZOrdering()		{			setChildIndex(targetList[0], numChildren-1);			if(player.Path || G1Data.gameGoal.quality == EGoal.COUNT)			{				//Util.debug("pex path", this);				setChildIndex(player, numChildren-2);				if(player.Path)					setChildIndex(player.Path, numChildren-3);			}			else				setChildIndex(player, numChildren-2);		}		//reset the goal : player's position needs to reach target position		function resetInstructions()		{			Util.debug("Game1.resetInstructions");			player.numMoves = 0;			G1Data.setInstructions();			tFeedbackText.text = G1Data.gameGoal.writtenPrompt;			G1Data.resetSuccess();			G1Data.firstTry = true;			//G1Data.SoundPlayer.forcePlaySoundFromQueue();		}		//Initialize events for the Arrow buttons		function initEvents(e:Event)		{			EventManager.addEvent			(tArrowUpButton, MouseEvent.CLICK, onArrowClick, GameData.UP);			EventManager.addEvent			(tArrowDownButton, MouseEvent.CLICK, onArrowClick, GameData.DOWN);			EventManager.addEvent			(tArrowRightButton, MouseEvent.CLICK, onArrowClick, GameData.RIGHT);			EventManager.addEvent			(tArrowLeftButton, MouseEvent.CLICK, onArrowClick, GameData.LEFT);			tGoButton.addEventListener(MouseEvent.CLICK, playerMoveToTarget, false, 0 , true);			if(stage)				stage.addEventListener (KeyboardEvent.KEY_UP, onKeyReleased, false, 0 , true);			player.addEventListener(TiledGameComponent.POSITION_CHANGED, onPlayerPositionChanged, false, 0 , true);		}		function removeEvents()		{			EventManager.removeEvent(tArrowUpButton, MouseEvent.CLICK);			EventManager.removeEvent(tArrowDownButton, MouseEvent.CLICK);			EventManager.removeEvent(tArrowRightButton, MouseEvent.CLICK);			EventManager.removeEvent(tArrowLeftButton, MouseEvent.CLICK);			tGoButton.removeEventListener(MouseEvent.CLICK, playerMoveToTarget);			stage.removeEventListener (KeyboardEvent.KEY_UP, onKeyReleased);			player.removeEventListener(TiledGameComponent.POSITION_CHANGED, onPlayerPositionChanged);			if(playerMoveTimer)			{				playerMoveTimer.removeEventListener(TimerEvent.TIMER, movePlayerFromList);				playerMoveTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, doneMovingPlayer);			}		}		//Move the player if still in bounds and update the current state of the game		function movePlayer(pDirection: Point2D, pLastArrow : DisplayObject)		{			if(clicksNotAllowed() || G1Data.lvl_ClickTarget)				return;			G1Data.FirstMove = 0;			player.lastArrow = pLastArrow;			player.lastDirection = pDirection.clone();			player.numMoves++;			lockPlayer = true;			Util.debug("state " + G1Data.State.Text, this);			Util.debug("tile " + player.CurrentTile , this);			player.CurrentTile = Util.addPoint2D(player.CurrentTile,pDirection);			Util.debug("testing new position to see if out of bounds " + player.CurrentTile);			if(!board.inBounds(player.CurrentTile))			{				//Player.CurrentTile = Player.Tile;				G1Data.State = EState.OUT_OF_BOUNDS;				return;			}			Util.debug("valid move", this);			//if position needs to be held, save the position in the List			//and display the correct arrow in the 'arrow List'			if(G1Data.lvl_HoldPosition)			{				Util.debug("length path " + arrowList.Rows.length);				Util.debug(G1Data.gameGoal.lengthOptimalPath);				if(arrowList.Rows.length > G1Data.gameGoal.lengthOptimalPath*2)				{					Util.debug("length path " + arrowList.Rows.length);					Util.debug(G1Data.gameGoal.lengthOptimalPath*2);					G1Data.State = EState.OUT_OF_BOUNDS;				}				//if path needs to be shown, draw it				arrowList.add(new Game1SmallArrow(pDirection));				if(G1Data.lvl_ShowPath)				{					player.pathToCurrentTile();					updateStateAfterMove(player.CurrentTile, player.previousTile);				}				else				{					G1Data.State = EState.IDLE;				}			}			//otherwise, move the player to the new location			else			{				player.moveByTile(pDirection, 0.6);				//G1Data.SoundPlayer.playSound(new KpmSound(Player.sound, 0.3));			}		}		//Move the player if still in bounds		//and update the current Game1Data		function onArrowClick(e:MouseEvent, pDirection: Point2D)		{            movePlayer(pDirection, e.target as DisplayObject);		}		function onKeyReleased(e:KeyboardEvent)		{			//G1Data.driver.stage.dispatchEvent(new Event(MouseEvent.MOUSE_MOVE));			G1Data.simulateMouseMoving();			switch (e.keyCode)			{				case Keyboard.UP :					if(G1Data.lvl_TargetVertical)						movePlayer(GameData.UP, tArrowUpButton);					break;				case Keyboard.DOWN :					if(G1Data.lvl_TargetVertical)						movePlayer(GameData.DOWN, tArrowDownButton);					break;				case Keyboard.LEFT :					if(G1Data.lvl_TargetHorizontal)						movePlayer(GameData.LEFT, tArrowLeftButton);					break;				case Keyboard.RIGHT :					if(G1Data.lvl_TargetHorizontal)						movePlayer(GameData.RIGHT, tArrowRightButton);					break;				case Keyboard.SPACE :					if(G1Data.lvl_HoldPosition)						playerMoveToTarget(null);					break;			}		}		public function clicksNotAllowed() : Boolean		{			//Util.debug(Player.Movie.currentLabel, this);//			Util.debug("");//			Util.debug("clicks not allowed ?")//			Util.debug("player at" + player.currentTile);//			Util.debug("state " + G1Data.State.Text, this);//			Util.debug(G1Data.keysLocked, this);//			Util.debug(lockPlayer);			if(player.Movie.currentLabel != "rest"			  || G1Data.State == EState.END_ANIMATION			  || playerMoveTimer			  || lockPlayer			  || G1Data.keysLocked			  //|| (G1Data.State == EState.INSTRUCTIONS && G1Data.firstLevel &&			  //	 (G1Data.Bubble.Level == 1 || G1Data.lvl_LockForInstructions))			  )			  {			  	 Util.debug("cant move" + player.currentTile);				 return true;			  }//			else//			{//				G1Data.State = EState.IDLE;//			}			Util.debug("can move!");			return false;		}		function playerMoveToTarget(e:Event = null)		{			if(targetMoveTimer)			{				targetMoveTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, playerMoveToTarget);	 			targetMoveTimer.stop();	 			arrowList.resetCounter();			}			if(!playerMoveTimer && arrowList.getNumMoviesLeft() != 0)			{				G1Data.stopTaskTimer();				movePlayerFromList(null);				Util.debug("movies left"+ arrowList.getNumMoviesLeft(), this);				if(arrowList.getNumMoviesLeft() > 0)				{					playerMoveTimer = new Timer(1000 , arrowList.getNumMoviesLeft());					playerMoveTimer.start();					playerMoveTimer.addEventListener(TimerEvent.TIMER, movePlayerFromList, false, 0 , true);					playerMoveTimer.addEventListener(TimerEvent.TIMER_COMPLETE, doneMovingPlayer, false, 0 , true);				}			}		}		public function movePlayerFromList(te:TimerEvent)		{			arrowList.getCurrentMovie().tArrow.gotoAndPlay("over");			//G1Data.SoundPlayer.playSound(new KpmSound(Player.sound, 0.5));			player.moveByTile(arrowList.NextMc.direction,0.7);			if(G1Data.gameGoal.quality == EGoal.COUNT)			for(var i=0; i < targetList.length ; i++)			{					if(targetList[i].Tile.equals(player.previousTile))						Util.removeChild(targetList[i]);			}		}		function onPlayerPositionChanged(e:Event)		{			updateStateAfterMove();		}		public function doneMovingPlayer(te:TimerEvent)		{			if(playerMoveTimer)			{				playerMoveTimer.stop();				playerMoveTimer = null;			}		}		function updateStateAfterMove(pTile : Point2D = null, pPreviousTile : Point2D = null)		{			Util.debug("Distance to target" + player.getDistanceToTarget(), this);			Util.debug("Player tile " + player.Tile, this);			if(!pTile)				pTile = player.Tile;			if(!pPreviousTile)				pPreviousTile = player.previousTile;			if(G1Data.lvl_ClickTarget)			{				if(arrowList.getNumMoviesLeft()==0)					G1Data.State = EState.END_ANIMATION;				return;			}			else if (G1Data.lvl_SpatialSense)			{				updateSpatialSenseAfterMove(pTile, pPreviousTile);			}		}		function updateSpatialSenseAfterMove(pTile : Point2D, pPreviousTile : Point2D)		{			//if holding position			//and at the end of the path and not at the target, bad move			//or if holding position and not showing path, and at obstacle			// if player makes a mistake, put the target at middle distance, if the distance			// between the player and the target is bigger than 1			Util.debug("Game1.updateSpatialSenseAfterMove " + board.logicBoard[pTile.x][pTile.y]);			if(G1Data.lvl_HoldPosition && arrowList.getNumMoviesLeft() == 0 && board.logicBoard[pTile.x][pTile.y] != Board.TILE_TARGET			  || (G1Data.lvl_HoldPosition && !G1Data.lvl_ShowPath && board.logicBoard[pTile.x][pTile.y] == Board.TILE_OBSTACLE))			{				player.Tile = player.initialTile;				var tempTile : Point2D = player.Tile.clone();				tempTile = Util.addPoint2D(tempTile,targetList[0].Tile);				tempTile = Util.multPoint2D(tempTile,0.5);				//Util.debug("middle tile " + tempTile, this);				Util.debug(" new tile position " + targetList[0].Tile)				if(Util.manhDistance(player.Tile, targetList[0].Tile) > 1)				{					targetList[0].Tile = tempTile.clone();					while(board.logicBoard[targetList[0].Tile.x][targetList[0].Tile.y] == Board.TILE_OBSTACLE)					{						Util.debug(" new tile position " + targetList[0].Tile)						targetList[0].Tile = Util.addNoiseTiles(targetList[0].Tile, Board.ONE_TILE);					}					board.initLogicBoard(targetList[0].Tile);				}				G1Data.State = EState.BAD_MOVE;				return;			}			if(board.logicBoard[pTile.x][pTile.y] == Board.TILE_OBSTACLE)			{				G1Data.State = EState.COLLISION;				return;			}			//if the previous position was closer than the current position			if(board.logicBoard[pTile.x][pTile.y] >			   board.logicBoard[pPreviousTile.x][pPreviousTile.y])			{				if(player.arrivedAtTarget &&				  (!pTile.equals(player.Tile) ||				  (G1Data.lvl_HoldPosition && !G1Data.lvl_ShowPath &&				   arrowList.getNumMoviesLeft()==0)))				{					player.arrivedAtTarget = false;					G1Data.State = EState.BAD_MOVE;				}				else					G1Data.State = EState.OK_MOVE;			}			else			{				G1Data.State = EState.GOOD_MOVE;			}			if(board.logicBoard[player.Tile.x][player.Tile.y] == Board.TILE_TARGET)			{				//Util.debug("movies left " + ArrowList.getNumMoviesLeft(), this);				if(G1Data.lvl_HoldPosition)				{					player.arrivedAtTarget = true;					if(arrowList.getNumMoviesLeft()==0)						G1Data.State = EState.END_ANIMATION;				}				else				{					G1Data.State = EState.END_ANIMATION;				}			}		}		//Function called when state is changed		public override function onStateChanged(e:Event)		{			lockPlayer = false;			Util.debug("Game1.onStateChanged ");			tFeedbackText.text = G1Data.Feedback;			if(G1Data.State == EState.END_ANIMATION || G1Data.State == EState.TOO_MANY_ATTEMPTS)			{				G1Data.stopTaskTimer();				removeAllTargets();				if(G1Data.Bubble.Name.ScoreType == EBScoreType.Proximity ||				   G1Data.Bubble.Name.ScoreType == EBScoreType.Path)				{					G1Data.taskXML.@initialTile = player.initialTile.Text;					G1Data.DistanceFromTarget = player.getDistanceToTarget();					if(G1Data.State == EState.END_ANIMATION)						G1Data.CurrentTaskSuccess = GameData.TASK_SUCCESS;				}				if(G1Data.needAnimation() && G1Data.State != EState.TOO_MANY_ATTEMPTS)				{					if(G1Data.gameGoal.quality == EGoal.COUNT)					{						player.Movie.gotoAndPlay("eatColor");						//Util.debug("count ?" + player.Movie.currentLabel);						Util.debug("count ?" + player.Movie.currentFrame);						Util.copyColor(targetList[G1Data.gameGoal.correctTargetIndex].Movie.tColor, player.Movie.tEatGray.tColor);						Util.debug("scale " + targetList[G1Data.gameGoal.correctTargetIndex].scaleX);						if(targetList[G1Data.gameGoal.correctTargetIndex].Movie.scaleX < 1)						{							player.Movie.tEatGray.scaleX = targetList[G1Data.gameGoal.correctTargetIndex].Movie.scaleX;							player.Movie.tEatGray.scaleY = targetList[G1Data.gameGoal.correctTargetIndex].Movie.scaleY;						}						Util.debug("slope " + Util.slope(player.Movie.scaleX));						Util.debug("slope " + Util.slope(player.scaleX));						if(player.defaultFacing != player.currentlyFacing)						{							player.Movie.tEatGray.scaleX *= -1;							if(G1Data.gameTheme == EGameCharacter.Mouse)								player.Movie.tEatGray.x += 1.5;						}						else if(G1Data.gameTheme == EGameCharacter.Bee)							player.Movie.y -= 2.5;					}					else						player.Movie.gotoAndPlay("eat");					if(targetList[0].Movie.visible)					{						targetList[0].Movie.visible = false;						player.Tile.x = targetList[0].Tile.x;						player.Tile.y = targetList[0].Tile.y;						//G1Data.SoundPlayer.pushSound(G1Data.createSound(EState.GOOD_MOVE.Text, 3));						if(G1Data.lvl_SpatialSense)                        {                            G1Data.soundLibrary.forceStop();                            G1Data.soundLibrary.playLibSound(ESoundType.Feedback, EState.GOOD_MOVE, G1Data.Language);                        }						addEventListener(Event.ENTER_FRAME, onAnimationProgress, false, 0 , true);						//G1Data.SoundPlayer.forcePlaySoundFromQueue(false);					}				}				else				{					G1Data.updateTask(3);				}				if(G1Data.State == EState.TOO_MANY_ATTEMPTS)					return;			}			if(G1Data.State == EState.GOOD_MOVE)			{                G1Data.gameGoal.lengthPath = player.numMoves;				setButtons(true);			}			if(G1Data.State == EState.OK_MOVE)			{				if(!(G1Data.lvl_HoldPosition && G1Data.lvl_ShowPath && !player.Tile.equals(player.initialTile)))				{					if(G1Data.previousState != EState.OK_MOVE)					{						G1Data.gameGoal.backtrackCounter++;                        G1Data.soundLibrary.forceStop();                        G1Data.soundLibrary.playLibSound(ESoundType.Feedback, EState.OK_MOVE, G1Data.Language);						//Util.debug("ok move " + G1Data.previousState.Text, this);						//G1Data.SoundPlayer.pushSound(G1Data.createSound(EState.OK_MOVE.Text, 2));						//G1Data.SoundPlayer.forcePlaySoundFromQueue();					}				}			}			if(G1Data.State == EState.BAD_MOVE || G1Data.State == EState.OUT_OF_BOUNDS				|| G1Data.State == EState.COLLISION)			{				if(G1Data.lvl_SpatialSense)				{					G1Data.gameGoal.lengthPath = player.numMoves;					G1Data.gameGoal.lengthOptimalPath = board.logicBoard[player.initialTile.x][player.initialTile.y];					G1Data.gameGoal.currentMove = player.Tile.Text;					G1Data.moveFailedXML.@state = G1Data.State.Text;					trySpatialSenseAgain();					G1Data.taskTimer.start();				}				G1Data.CurrentTaskSuccess = GameData.TASK_FAILURE;				tryAgainSound();				//G1Data.keysLocked = true;			}			if(mData.State != EState.IDLE && mData.State != EState.INSTRUCTIONS)			{				mData.previousState = mData.State;			}		}		function removeAllTargets()		{			for(var i=0; i< targetList.length; i++)				if(targetList[i] && targetList[i].parent == this)					removeChild(targetList[i]);		}		function trySpatialSenseAgain()		{			doneMovingPlayer(null);			if(!G1Data.lvl_ShowPath && !G1Data.lvl_HoldPosition)			{				player.Tile = player.previousTile; 			}			Util.debug("try again. player is now at " + player.CurrentTile);			player.CurrentTile = player.Tile;			setArrowList();			setPlayerPath();			setAssetsZOrdering();			if(!arrowNeeded(player.lastDirection) && !(G1Data.lvl_HoldPosition && !G1Data.lvl_ShowPath))				player.lastArrow.visible = false;			G1Data.State = EState.IDLE;		}		function tryAgainSound()		{			G1Data.firstTry = false;            G1Data.soundLibrary.forceStop();            if(	G1Data.gameGoal.quality == EGoal.COLOR ||				G1Data.gameGoal.quality == EGoal.SIZE ||				G1Data.gameGoal.quality == EGoal.NUMBER ||				G1Data.gameGoal.quality == EGoal.COUNT)			{				G1Data.feedbackSound = clickedTarget.feedbackSound;                G1Data.soundLibrary.playLibSound(ESoundType.Feedback, EState.BAD_MOVE);				G1Data.soundLibrary.playLibSound(ESoundType.Feedback, "Silence1");				if(G1Data.gameGoal.quality == EGoal.NUMBER || G1Data.gameGoal.quality == EGoal.COUNT)					G1Data.soundLibrary.playLibSound(ESoundType.FeedbackClick, clickedTarget.feedbackSound, G1Data.Language, null, null, null, GameData.FEEDBACK_FINISHED);				if(G1Data.gameGoal.quality == EGoal.COLOR || G1Data.gameGoal.quality == EGoal.SIZE)					if(Math.random() < 1)						G1Data.soundLibrary.playLibSound(ESoundType.FeedbackClick, clickedTarget.feedbackSound, G1Data.Language, null, null, null, GameData.FEEDBACK_FINISHED);					else						G1Data.soundLibrary.playLibSound(ESoundType.FeedbackClick, clickedTarget.feedbackSound, G1Data.Language, EGame.G1, G1Data.gameTheme, G1Data.Bubble.Name, GameData.FEEDBACK_FINISHED);			}			else if(G1Data.State == EState.COLLISION || G1Data.State == EState.OUT_OF_BOUNDS)			{				G1Data.soundLibrary.playLibSound(ESoundType.Feedback, GameData.INVALID_MOVE);			}			//!! need to call unlock keys when this is over ?			else				G1Data.soundLibrary.playLibSound(ESoundType.Feedback, GameData.TRY_AGAIN, G1Data.Language, null, null, null, GameData.FEEDBACK_FINISHED);		}		public override function onFeedbackFinished(e:Event)		{			G1Data.State = EState.INSTRUCTIONS;			//if(Util.getRandBtw(0,1) == 0)			//G1Data.soundLibrary.playLibSound(ESoundType.Instruction, "Interjection", G1Data.Language);			//else				G1Data.soundLibrary.playLibSound(ESoundType.Feedback, "Silence1");			G1Data.setInstructions();		}		public function repeatQuestion()		{			G1Data.repeatQuestion();		}		function arrowNeeded(pDirection)		{			if(G1Data.State == EState.COLLISION)				return true;			if(pDirection.x)				if(Util.slope(targetList[0].Tile.x - player.Tile.x) == pDirection.x)					return true;			if(pDirection.y)				if(Util.slope(targetList[0].Tile.y - player.Tile.y) == pDirection.y)					return true;			return false;		}		public function onAnimationProgress (e:Event)		{			if(player.Movie.currentLabel == "EAT_ANIMATION_DONE")			{				G1Data.State = EState.IDLE;				G1Data.updateTask(3);				this.removeEventListener(Event.ENTER_FRAME, onAnimationProgress);			}		}		public function getDistanceToTarget(pPrevious : Boolean)		{			return player.getDistanceToTarget(pPrevious);		}		public function get G1Data() : Game1Data		{			return (mData as Game1Data)		}		public override function get Data()		{			return (mData as Game1Data);		}		public function get Name()		{			return EGame.G1;		}		public override function blinkSolution()		{			for(var i=0; i < G1Data.gameGoal.numCorrectOptions; i++)			{				targetList[i].startBlink(GameData.BLINK_PERIOD, GameData.NUM_TIMES_BLINK);			}		}	}}